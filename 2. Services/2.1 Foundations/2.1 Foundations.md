# 2.1 Services de fondation (Broker-Voisin)

## 2.1.0 Introduction

Les services de fondation sont le first point de contact entre votre logique métier et les brokers.

En général, les services de courtage et de voisinage sont un hybride de logique commerciale et une couche d'abstraction pour les opérations de traitement où se produit la logique commerciale d'ordre supérieur, dont nous parlerons plus en détail lorsque nous commencerons à explorer les services de traitement dans la section suivante.

Les services de courtage et de voisinage ont pour principale responsabilité de garantir que les données entrantes et sortantes du système sont validées et contrôlées sur le plan structurel, logique et externe.

Vous pouvez également considérer les services de voisinage des courtiers comme une couche de validation au-dessus des opérations primitives que les courtiers offeraient déjà.

Par exemple, si un broker de stockage propose `InsertStudentAsync(Student student)` comme méthode, le service voisin du broker offrira quelque chose comme suit :

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
}
```

Cela fait des services voisins du broker rien de plus qu'une couche supplémentaire de validation en plus des opérations primitives existantes que les courtiers offrent déjà.

## 2.1.1 Sur la carte

Les services voisins du broker résident entre vos courtiers et le reste de votre application, sur le côté gauche les services de traitement de la logique métier d'ordre supérieur, les services d'orchestration, de coordination, d'agrégation ou de gestion peuvent vivre, ou simplement un contrôleur, un composant d'interface utilisateur ou tout autre autre technologie d'exposition des données.

<br/>
	<p align=center>
		<img src="https://user-images.githubusercontent.com/1453985/100716772-00eec800-336e-11eb-9064-8bfe2f8e3be2.png" />
	</p>
<br/>

## 2.1.2 Caractéristiques

Fondation ou Les services Broker-Voisin en général ont des caractéristiques très spécificales qui régissent strictement leur développement et leur intégration.

En général, les services de la Fondation se concentrent plus sur les validations que sur toute autre chose, tout simplement parce que c'est leur objectif, à savoir garantir que toutes les données entrantes et sortantes du système sont dans un bon état pour que le système puisse les traiter en toute sécurité et sans problème.

Voici les caractéristiques et les règles qui régissent les services de courtage entre voisins :

### 2.1.2.0 Primitif-pur

Les services voisins du broker ne sont pas autorisés à combiner plusieurs opérations primitives pour obtenir une opération de logique métier d'ordre supérieur.

Par exemple, les services voisins du broker ne peuvent pas offrir une fonction _upsert_, pour combiner une opération `Select` avec une opération `Update` ou `Insert` basée sur le résultat pour s'assurer qu'une entité existe et est à jour dans n'importe quel stockage.

Mais ils offrent un wrapper de validation et de gestion des exceptions (et de mappage) autour des appels de dépendance, voici un exemple :

```csharp
public ValueTask<Student> AddStudentAsync(Student student) =>
TryCatch(async () =>
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
});
```

Dans la méthode ci-dessus, vous pouvez voir l'appel de la fonction `ValidateStudent` précédé d'un bloc `TryCatch`.
Le bloc `TryCatch` est ce que j'appelle le modèle Exception Noise Cancellation, dont nous parlerons bientôt dans cette section.

Mais la fonction de validation garantit que chaque propriété des données entrantes est validée avant de la transmettre à l'opération de broker primitive, qui est `InsertStudentAsync` dans ce cas précis.

### 2.1.2.1 Intégration d'une entité unique

Les services garantissent fortement que le principe de responsabilité unique est mis en œuvre en ne s'intégrant à aucun autre broker d'entité, à l'exception de celui qu'il prend en charge.

Cette règle ne s'applique pas nécessairement aux courtiers de support comme `DateTimeBroker` ou `LoggingBroker` puisqu'ils ne ciblent pas spécifiquement une entité commerciale particulière et qu'ils sont presque génériques sur l'ensemble du système.

Par exemple, un `StudentService` peut s'intégrer à un `StorageBroker` tant qu'il ne cible que les fonctionnalités offertes par la classe partielle dans le fichier `StorageBroker.Students.cs`.

Les services de base ne doivent pas s'intégrer à plus d'un broker d'entité de quelque nature que ce soit simplement parce que cela augmentera la complexité de la validation et de l'orchestration qui va au-delà de l'objectif principal du service qui est simplement la validation. Nous poussons cette responsabilité plus loin aux services de type orchestration pour la prendre en charge.

### 2.1.2.2  Langage de métier

Les services Broker-Voisin utilisent un langage commercial primitif pour leurs opérations.
Par exemple, alors qu'un Broker peut fournir une méthode avec le nom `InsertStudentAsync` - l'équivalent de celle sur la couche de service serait `AddStudentAsync`.

En général, la plupart des opérations CRUD doivent être converties d'un langage de stockage vers un langage métier, et il en va de même pour les opérations non liées au stockage telles que les files d'attente, par exemple, nous disons `PostQueueMessage` mais sur la couche métier, nous dirons `EnqueueMessage `.

Étant donné que les opérations CRUD sont les plus courantes dans tous les systèmes, notre mappage à ces opérations CRUD serait le suivant :

| Brokers | Services |
| ------- | :------: |
| Insert  |   Add    |
| Select  | Retrieve |
| Update  |  Modify  |
| Delete  |  Remove  |

Au fur et à mesure que nous avançons vers des services de logique métier d'ordre supérieur, le langage des méthodes utilisées s'orientera davantage vers un langage métier plutôt que vers un langage technologique comme nous le verrons dans les sections à venir.

## 2.1.3 Responsabilités

Les services de courtage voisins jouent trois rôles très importants dans tout système.
Le premier rôle est d'abstraire les opérations du broker natif du reste du système. Indépendamment du fait qu'un broker soit une communication entre un stockage local ou externe ou une API - les services voisins du broker auront toujours le même contrat/verbiage à exposer aux services de flux supérieurs tels que le traitement, l'orchestration ou simplement les exposants comme les contrôleurs ou les composants de l'interface utilisateur.
Le deuxième rôle, et le plus important, est d'offrir une couche de validation en plus des opérations primitives existantes qu'un broker offre déjà pour garantir que les données entrantes et sortantes sont valides pour être traitées ou conservées par le système.
Le troisième rôle est de jouer le rôle d'un mappeur de tous les autres modèles et contrats natifs qui peuvent être nécessaires pour mener à bien une opération donnée tout en s'interfaçant avec un broker.
Les services de base sont le dernier point d'abstraction entre la logique métier de base de tout système et le reste du monde, discutons de ces rôles en détail.

### 2.1.3.0 Abstraction

La première et la plus importante responsabilité des services voisins de la fondation/broker est de s'assurer qu'un niveau d'abstraction existe entre les courtiers et le reste de votre système. Cette abstraction est nécessaire pour garantir que la couche de logique métier pure de tout système est verbalement et fonctionnellement indépendante des dépendances sur lesquelles le système s'appuie pour communiquer avec le monde extérieur.

Visualisons un exemple concret du principe ci-dessus. Supposons que nous ayons un `StudentProcessingService` qui implémente une fonctionnalité `UpsertStudentAsync`. Quelque part dans cette implémentation, il y aura une dépendance sur `AddStudentAsync` qui est exposée et implémentée par certains `StudentService` en tant que service de base. Jetez un oeil à cet extrait:

```csharp
public async ValueTask<Student> UpsertStudentAsync(Student student)
{
	...

	return await this.studentService.AddStudentAsync(student);
}
```

Le contrat entre un service de traitement ou d'orchestration et un service de base sera toujours le même quel que soit le type d'implémentation ou le type de courtiers utilisés par le service de base.
Par exemple, `AddStudentAsync` peut être un appel à une base de données ou à un point de terminaison d'API ou simplement placer un message dans une file d'attente. Tout cela n'a aucune incidence sur l'implémentation du service de traitement en amont. voici un exemple de trois implémentations différentes d'un service de base qui ne changeraient rien à l'implémentation de ses services en amont :

Avec un broker en stockage :

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	...
	return await this.storageBroker.InsertStudentAsync(student);
}
```

Ou avec un broker de file d'attente :

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	...

	return await this.queueBroker.EnqueueStudentAsync(student);
}
```

ou avec un broker d'API :

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	...

	return await this.apiBroker.PostStudentAsync(student);
}
```

voici une visualisation de ce concept :

<br />

<div align=center>
	<img width="75%" src="https://user-images.githubusercontent.com/1453985/128610577-ee926ee2-a589-4f77-bf9d-dbff63d1c20d.png" />
</div>

<br />

Dans tous ces cas ci-dessus, l'implémentation sous-jacente peut changer, mais le contrat exposé restera toujours le même pour le reste du système. Nous verrons dans les chapitres suivants comment la logique métier de base, agnostique et abstraite de votre système commence par les services de traitement et se termine par les services de gestion ou d'agrégation.

#### 2.1.3.0.1 Implémentation

Parlons d'un exemple concret d'implémentation d'une simple fonction `Add` dans un service de base. Supposons que nous ayons le contrat suivant pour notre `StudentService` :

```csharp
public IStudentService
{
	ValueTask<Student> AddStudentAsync(Student student);
}
```

Pour commencer, allons-y et écrivons un test d'échec pour notre service comme suit:

```csharp
public async Task ShouldAddStudentAsync()
{
	// given
	Student randomStudent = CreateRandomStudent();
	Student inputStudent = randomStudent;
	Student storageStudent = inputStudent;
	Student expectedStudent = storageStudent.DeepClone();

	this.storageBrokerMock.Setup(broker =>
		broker.InsertStudentAsync(inputStudent))
			.ReturnsAsync(storageStudent);

	// when
	Student actualStudent =
		await this.studentService.AddStudentAsync(inputStudent);

	// then
	actualStudent.Should().BeEquivalentTo(expectedStudent);

	this.storageBroker.Verify(broker =>
		broker.InsertStudentAsync(inputStudent),
			Times.Once);

	this.storageBroker.VerifyNoOtherCalls();
	this.loggingBroker.VerifyNoOtherCalls();
}
```

Dans le test ci-dessus, nous avons défini quatre variables avec la même valeur. Chaque variable contient un nom qui correspond le mieux au contexte dans lequel elle sera utilisée. Par exemple, `inputStudent` correspond le mieux à la position du paramètre d'entrée, tandis que `storageStudent` correspond le mieux à ce qui est renvoyé par le broker de stockage après la persistance réussie d'un étudiant.

Vous remarquerez également que nous avons cloné en profondeur la variable `expectedStudent` pour nous assurer qu'aucune modification n'a été apportée à l'étudiant transmis à l'origine. Par exemple, supposons qu'une valeur étudiant d'entrée a changé pour l'un de ses attributs en interne dans la fonction `AddStudentAsync`. Cette modification ne déclenchera pas d'échec de test à moins que nous ne déréférencions la variable `expectedStudent` des variables d'entrée et renvoyées.

Nous nous moquons de la réponse du broker de stockage et exécutons notre sujet de test `AddStudentAsync` puis nous vérifions que la valeur étudiante renvoyée `actualStudent` correspond à la valeur attendue `expectedStudent` quelle que soit la référence.

Enfin, nous vérifions que tous les appels sont effectués correctement et qu'aucun appel supplémentaire n'a été effectué vers l'une des dépendances de service.

Faisons passer ce test en écrivant dans une implémentation qui ne satisfait qu'aux exigences du test susmentionné :

```csharp
public async ValueTask<Student> AddStudentAsync(Student student) =>
	await this.storageBroker.InsertStudentAsync(student);
```

Cette implémentation simple devrait faire passer notre test avec succès. Il est important de comprendre que toute implémentation ne devrait suffire qu'à réussir les tests qui échouent. Rien de plus et rien de moins.

### 2.1.3.1 Validation

Les services de base sont nécessaires pour s'assurer que les données entrantes et sortantes depuis et vers le système sont en bon état - ils jouent le rôle de gardien entre le système et le monde extérieur pour s'assurer que les données qui transitent sont structurellement, logiquement et extérieurement valides avant effectuer toute autre opération par les services en amont.
L'ordre des validations ici est très intentionnel. Les validations structurelles sont les moins chères des trois types. Ils garantissent qu'un attribut particulier ou une donnée en général n'a pas de valeur par défaut si cela est nécessaire. l'opposé de cela sont les validations logiques, où les attributs sont comparés à d'autres attributs avec la même entité ou toute autre. Des validations logiques supplémentaires peuvent également inclure une comparaison avec une valeur constante, comme comparer l'âge d'inscription d'un étudiant à au moins 5 ans.
Les validations structurelles et logiques viennent avant l'externe. Comme nous l'avons dit, c'est simplement parce que nous ne voulons pas payer le coût de la communication avec une ressource externe, y compris la taxe de latence, si notre demande n'est pas en bonne forme en premier.
Par exemple, nous ne devrions pas essayer de publier un objet `Student` sur une API externe si l'objet est `null`. Ou si le modèle `Student` est structurellement ou logiquement invalide.

Pour tous les types de validations, il est important de comprendre que certaines validations coupent le circuit ou nécessitent une sortie immédiate du flux actuel en levant une exception ou en retournant une valeur dans certains cas. Et certaines autres validations sont continues. Parlons d'abord de ces deux sous-catégories de validations.

#### 2.1.3.1.0 Circuit-Breaking Validations

Les validations de disjoncteur nécessitent une sortie immédiate du flux de courant. Par exemple, si un objet passé dans une fonction est `null` - aucune autre opération n'est requise à ce niveau autre que la sortie du flux actuel en levant une exception ou en renvoyant une valeur d'un certain type. Voici un exemple :
Dans certains scénarios de validation, supposons que notre fonction `AddStudent` ait un étudiant de valeur `null` qui lui est transmis comme suit :

```csharp
Student noStudent = null;

await this.studentService.AddStudentAsync(noStudent);
```

Notre fonction `AddStudentAsync` dans ce scénario doit maintenant valider si le paramètre transmis est `null` ou non avant d'aller plus loin avec tout autre type de validations ou la logique métier elle-même. Quelque chose comme ça:

```csharp
public Student AddStudentAsync(Student student) =>
TryCatch(async () =>
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
});
```

La déclaration en question ici est la fonction `ValidateStudent` et ce qu'elle fait. Voici un exemple de la façon dont cette routine serait implémentée :

```csharp
private void ValidateStudent(Student student)
{
	if(student is null)
	{
		throw new NullStudentException();
	}
}
```

Dans la fonction ci-dessus, nous avons décidé de lever l'exception immédiatement au lieu d'aller plus loin. C'est un exemple de type de validation de disjoncteur.

Mais avec les validations, couper le circuit n'est pas toujours la chose la plus sage à faire. Parfois, nous souhaitons collecter tous les problèmes d'une demande particulière avant de renvoyer le rapport d'erreur à l'émetteur de la demande. Parlons-en dans cette section suivante.

#### 2.1.3.1.1 Validations continues

Les validations continues sont à l'opposé des validations par coupure de circuit. Ils n'arrêtent pas le flux des validations mais ils arrêtent définitivement le flux de la logique. En d'autres termes, les validations continues garantissent qu'aucune logique métier ne sera exécutée, mais elles garantissent également que d'autres validations du même type peuvent continuer à s'exécuter avant de rompre le circuit. Matérialisons cette théorie par un exemple :
Supposons que notre modèle étudiant ressemble à ceci :

```csharp
public class Student
{
	public Guid Id {get; set;}
	public string Name {get; set;}
}
```

En supposant que le modèle `Student` transmis n'est pas nul, mais il a des valeurs par défaut dans tous les domaines pour toutes ses propriétés. Nous souhaitons collecter tous ces problèmes pour le nombre d'attributs/propriétés de cet objet et renvoyer un rapport complet au demandeur. Voici comment procéder.

#### 2.1.3.1.1.0 Exceptions modifiables

Un problème de ce type nécessite un type spécial d'exceptions qui permettent de collecter toutes les erreurs dans sa propriété `Data`. Chaque exception native contiendra la propriété `Data` qui est essentiellement un dictionnaire pour une paire clé/valeur permettant de collecter plus d'informations sur les problèmes qui ont provoqué l'apparition de cette exception.
Le problème avec ces exceptions natives est qu'elles n'ont pas de support natif pour l'upsertion. Pouvoir ajouter à une liste de valeurs existante une clé particulière à tout moment.
Voici une implémentation native des valeurs upserting dans un dictionnaire donné :

```csharp
var someException = new Exception();

if(someException.Data.Contains(someKey))
{
	(someException.Data[someKey] as List<string>)?.Add(someValue);
}
else
{
	someException.Data.Add(someKey, new List<string>{ someValue });
}
```

Cette implémentation peut être assez décourageante pour les ingénieurs à réfléchir et à tester dans leur implémentation de niveau de service. Il a semblé plus approprié d'introduire une bibliothèque simple `Xeptions` pour simplifier l'implémentation ci-dessus en quelque chose d'aussi simple que :

```csharp
var someException = new Xeption();
someException.UpsertData(someKey, someValue);
```

Maintenant que nous avons cette bibliothèque à utiliser, le souci d'implémenter des exceptions modifiables a été résolu. Cela signifie que nous avons ce qu'il faut pour collecter nos erreurs de validation. Mais ce n'est pas suffisant si nous n'avons pas de mécanisme pour rompre le circuit lorsque nous pensons que le moment est venu de le faire.
On peut simplement utiliser les offres natives pour implémenter directement le disjoncteur comme suit :

```csharp
if(someException.Data.Count > 0)
{
	throw someException;
}
```

Et bien que cela puisse être facilement intégré à n'importe quelle implémentation existante. Cela n'a toujours pas beaucoup contribué à l'apparence générale du code. Par conséquent, j'ai décidé d'en faire une partie de la bibliothèque `Xeptions` pour être simplifiée comme suit :

```csharp
someException.ThrowIfContainsErrors();
```

Cela ferait ressembler nos validations personnalisées à ceci :

```csharp
public class InvalidStudentException : Xeption
{
	public InvalidStudentException()
		: base ("Student is invalid. Please fix the errors and try again.")
	{ }
}
```

Mais avec des validations continues, le processus de collecte de ces erreurs transmet plus qu'une simple implémentation d'exception spéciale. Parlons de cela dans la section suivante.

#### 2.1.3.1.1.1 Règles dynamiques

Un processus de validation sans coupure de circuit ou continu nécessitera la possibilité de transmettre des règles dynamiques à n'importe quel nombre ou capacité pour ajouter ces erreurs de validation. Une règle de validation est une structure dynamique qui signale si la règle a été violée pour sa condition ; ainsi que le message d'erreur qui doit être signalé à l'utilisateur final pour l'aider à résoudre ce problème.

Dans un scénario où nous voulons nous assurer qu'un identifiant donné est valide, une règle de validation continue dynamique ressemblerait à ceci :

```csharp
private static dynamic IsInvalid(Guid id) => new
{
	Condition = id == Guid.Empty,
	Message = "Id is required"
};
```

Maintenant, notre règle ne se contente pas de signaler si un attribut particulier est invalide ou non. Il contient également un message significatif lisible par l'homme qui aide le consommateur du service à comprendre ce qui rend cet attribut invalide.

Il est vraiment important de souligner le langage que les ingénieurs doivent utiliser pour les messages de validation. Tout dépendra des consommateurs potentiels de votre système. Un non-ingénieur ne comprendra pas un message tel que `Text cannot be null, empty or whitespace` - `null` car un terme n'est pas très couramment utilisé. Les ingénieurs doivent travailler en étroite collaboration avec leur viande (les personnes qui utilisent le système) pour s'assurer que le langage a du sens pour eux.

Les règles dynamiques par conception permettront aux ingénieurs de modifier à la fois leurs entrées et leurs sorties sans interrompre les fonctionnalités existantes tant que les valeurs `null` sont prises en compte dans tous les domaines. Voici une autre manifestation d'une règle de validation dynamique :

```csharp
private static dynamic IsNotSame(
	Guid firstId,
	Guid secondId,
	string secondIdName) => new
{
	Condition = firstId != secondId,
	Message = $"Id is not the same as {secondIdName}.",
	HelpLink = "/help/code1234"
};
```

Notre règle dynamique peut désormais offrir plus de paramètres d'entrée et des informations plus utiles en termes de message d'exception plus détaillé avec des liens vers des sites de documentation utiles ou des références pour les codes d'erreur.

#### 2.1.3.1.1.2 Collecteur de règles et de validations

Maintenant, qui ont les exceptions avancées et les règles de validation dynamiques. Il est temps de tout mettre ensemble en termes d'acceptation d'un nombre infini de règles de validation, d'examen de leurs résultats de condition et enfin de rompre le circuit lorsque toutes les validations continues sont effectuées. voici comment procéder :

```csharp
private void Validate(params (dynamic Rule, string Parameter)[] validations)
{
	var invalidStudentException = new InvalidStudentException();

	foreach((dynamic rule, string parameter) in validations)
	{
		if(rule.Condition)
		{
			invalidStudentException.UpsertData(parameter, rule.Message);
		}
	}

	invalidStudentException.ThrowIfContainsErrors();
}
```

La fonction ci-dessus prendra maintenant n'importe quel nombre de règles de validation, et les paramètres sur lesquels la règle s'exécute examinent ensuite les conditions et annulent le rapport d'erreurs. Voici comment nous pouvons utiliser la méthode ci-dessus:

```csharp
private void ValidateStudent(Student student)
{
	Validate(
		(Rule: IsInvalid(student.Id), Parameter: nameof(Student.Id)),
		(Rule: IsInvalid(student.Name), Parameter: nameof(Student.name)),
		(Rule: IsInvalid(student.Grade), Parameter: nameof(Student.Grade))
	);
}
```

Cette simplification de l'écriture des règles et des validations est le but ultime de continuer à apporter de la valeur aux utilisateurs finaux tout en rendant le processus d'ingénierie de la solution agréable pour les ingénieurs eux-mêmes.

Maintenant, approfondissons les types de validations que nos systèmes peuvent offrir et comment les gérer.

#### 2.1.3.1.2 Validations structurelles

Les validations sont trois couches différentes. la première de ces couches est celle des validations structurelles. pour s'assurer que certaines propriétés d'un modèle donné ou d'un type primitif ne sont pas dans un état structurel invalide.

Par exemple, une propriété de type `String` ne doit pas être vide, `null` ou un espace blanc. un autre exemple serait pour un paramètre d'entrée de type `int`, il ne devrait pas être à son état `default` qui est `0` lorsque vous essayez d'entrer un âge par exemple.

Les validations structurelles garantissent que les données sont en bon état avant d'aller de l'avant avec d'autres validations - par exemple, nous ne pouvons pas valider qu'un étudiant a le nombre minimum de caractères (ce qui est une validation logique) dans son nom si son prénom est structurellement invalide structurellement en étant `null`, vide ou espace.

Les validations structurelles jouent le rôle d'identifier les propriétés _requises_ sur un modèle donné, et bien que de nombreuses technologies offrent les annotations de validation, les plugins ou les bibliothèques pour appliquer globalement les règles de validation des données, je choisis d'effectuer la validation par programmation et manuellement pour mieux contrôler ce qui serait nécessaire et ce qui ne le serait pas d'une manière TDD.

Le problème avec certaines des implémentations actuelles des validations structurelles et logiques sur les modèles de données est qu'elles peuvent être très facilement modifiées sous le radar sans qu'aucun test unitaire ne déclenche d'alarme. Vérifiez cet exemple par exemple :

```csharp
public Student
{
	[Required]
	public string Name {get; set;}
}
```

L'exemple ci-dessus peut être très attrayant en un coup d'œil d'un point de vue technique. Tout ce que vous avez à faire est de décorer votre attribut de modèle avec une annotation magique et puis tout d'un coup vos données sont validées.

Le problème ici est que ce modèle combine deux responsabilités différentes ou plus ensemble dans le même modèle. Les modèles sont censés n'être qu'une représentation d'objets dans la réalité - rien de plus et rien de moins. Certains ingénieurs les appellent des modèles anémiques qui concentrent la responsabilité de chaque modèle pour ne représenter que les attributs de l'objet du monde réel qu'il essaie de simuler sans aucun détail supplémentaire.

Mais les modèles annotés tentent désormais d'injecter une logique métier dans leurs définitions mêmes. Cette logique métier peut être nécessaire ou non pour tous les services, courtiers ou composants d'exposition qui les utilisent.

Les validations structurelles sur des modèles peuvent sembler être un travail supplémentaire qui peut être évité avec des décorations magiques. Mais dans le cas où vous essayez de diverger légèrement de ces validations vers des validations plus personnalisées, vous verrez maintenant un nouvel anti-modèle émerger comme des annotations personnalisées qui peuvent ou non être détectables via des tests unitaires.

Parlons de la façon de tester une routine de validation structurelle:

##### 2.1.3.1.2.0 Tester les validations structurelles

Parce que je crois vraiment en l'importance de TDD (Test-Driven Development), je vais commencer à montrer l'implémentation des validations structurelles en écrivant d'abord un test d'échec pour celui-ci.

Supposons que nous ayons un modèle étudiant, avec les détails suivants :


```csharp
public class Student
{
	public Guid Id {get; set;}
}
```

Nous voulons valider que l'identifiant de l'étudiant n'est pas un identifiant structurellement invalide - tel qu'un `Guid` vide - nous écrirons donc un test unitaire de la manière suivante :

```csharp
[Fact]
public async void ShouldThrowValidationExceptionOnRegisterWhenIdIsInvalidAndLogItAsync()
{
	// given
	Student randomStudent = CreateRandomStudent();
	Student inputStudent = randomStudent;
	inputStudent.Id = Guid.Empty;

	var invalidStudentException = new InvalidStudentException();

	invalidStudentException.AddData(
		key: nameof(Student.Id),
		value: "Id is required"
	);

	var expectedStudentValidationException =
		new StudentValidationException(invalidStudentException);

	// when
	ValueTask<Student> registerStudentTask =
		this.studentService.RegisterStudentAsync(inputStudent);

	StudentValidationException actualStudentValidationException =
		await Assert.ThrowsAsync<StudentValidationException>(
			registerStudentTask.AsTask);

	// then
	actualStudentValidationException.Should().BeEquivalentTo(
		expectedStudentValidationException);

	this.loggingBrokerMock.Verify(broker =>
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentValidationException))),
				Times.Once);

	this.storageBrokerMock.Verify(broker =>
		broker.InsertStudentAsync(It.IsAny<Student>()),
			Times.Never);

	this.dateTimeBrokerMock.VerifyNoOtherCalls();
	this.loggingBrokerMock.VerifyNoOtherCalls();
	this.storageBrokerMock.VerifyNoOtherCalls();
}
```

Dans le test ci-dessus, nous avons créé un objet étudiant aléatoire, puis attribué une valeur d'ID non valide de `Guid.Empty` à l'étudiant `Id`.

Lorsque la logique de validation structurelle de notre service de base examine la propriété `Id`, elle doit générer une propriété d'exception décrivant le problème de validation dans notre modèle étudiant. dans ce cas, nous lançons `InvalidStudentException`.

L'exception est nécessaire pour décrire brièvement le quoi, le où et le pourquoi de l'opération de validation. dans notre cas, ici, quel serait le problème de validation, où serait le service étudiant et pourquoi serait la valeur de la propriété.

Voici à quoi ressemblerait une `InvalidStudentException` :

```csharp
public class InvalidStudentException : Xeption
{
	public InvalidStudentException()
		:base ("Student is invalid. Please fix the errors and try again.")
	{ }
}
```

Cependant, le test unitaire ci-dessus nécessite que notre `InvalidStudentException` soit enveloppé dans une exception plus générique au niveau du système, qui est `StudentValidationException` - ces exceptions sont ce que j'appelle des exceptions externes, elles encapsulent toutes les différentes situations de validations indépendamment de leur catégorie et communique l'erreur aux services ou aux contrôleurs en amont afin qu'ils puissent la mapper au code d'erreur approprié pour le consommateur de ces services.

Notre `StudentValidationException` serait implémenté comme suit :

```csharp
public class StudentValidationException : Exception
{
	public StudentValidationException(Exception innerException)
		: base("Student validation error occurred, please check your input and then try again.", innerException) { }
}
```

Le message dans la validation externe ci-dessus indique que le problème est dans l'entrée, et par conséquent, il nécessite que l'auteur de l'entrée réessaye car aucune action n'est requise du côté système pour être ajustée.

##### 2.1.3.1.2.1 Implémentation de validations structurelles

Maintenant, regardons l'autre côté du processus de validation, qui est la implémentation.
Les validations structurelles viennent toujours avant tous les autres types de validations. C'est simplement parce que les validations structurelles sont les moins chères du point de vue de l'exécution et du temps asymptotique.
Par exemple, il est beaucoup moins cher de valider qu'un `Id` est structurellement invalide, que d'envoyer un appel API pour obtenir exactement la même réponse plus le coût de la latence. Tout cela s'additionne lorsque plusieurs millions de requêtes par seconde commencent à affluer.
Les validations structurelles et logiques vivent en général dans leur propre classe partielle pour exécuter ces validations, par exemple, si notre service s'appelle "StudentService.cs", un nouveau fichier doit être créé avec le nom "StudentService.Validations.cs" pour encapsuler et abstraction visuelle des règles de validation pour s'assurer que des données propres entrent et sortent.
Voici à quoi ressemblerait une validation d'Id :

###### StudentService.Validations.cs

```csharp

private void ValidateStudent(Student student)
{
	Validate((Rule: IsInvalid(student.Id), Parameter: nameof(Student.Id)));
}

private static dynamic IsInvalid(Guid id) => new
{
	Condition = id == Guid.Empty,
	Message = "Id is required"
};

private void Validate(params (dynamic Rule, string Parameter)[] validations)
{
	var invalidStudentException = new InvalidStudentException();

	foreach((dynamic rule, string parameter) in validations)
	{
		if(rule.Condition)
		{
			invalidStudentException.UpsertData(parameter, rule.Message);
		}
	}

	invalidStudentException.ThrowIfContainsErrors();
}
```

Nous avons implémenté une méthode pour valider l'intégralité de l'objet étudiant, avec une compilation de toutes les règles que nous devons mettre en place pour valider structurellement et logiquement l'objet d'entrée étudiant. La partie la plus importante à noter à propos de l'extrait de code ci-dessus est d'assurer l'encapsulation de tous les détails plus fins plus éloignés de l'objectif principal d'une méthode particulière.

C'est la raison pour laquelle nous avons décidé d'implémenter une méthode statique privée `IsInvalid` pour résumer les détails de ce qui détermine qu'une propriété de type `Guid` est invalide ou non. Et à mesure que nous avançons dans l'implémentation, nous allons devoir implémenter plusieurs surcharges de la même méthode pour valider structurellement et logiquement d'autres types de valeurs.

Le but de la méthode `ValidateStudent` est simplement de configurer les règles et de prendre une action en levant une exception si l'une de ces règles est violée. Il est toujours possible d'agréger les erreurs de violation plutôt que de lancer trop tôt le premier signe de problème de validation structurel ou logique à détecter.

Maintenant, avec l'implémentation ci-dessus, nous devons appeler cette méthode pour valider structurellement et logiquement notre entrée. Faisons cet appel dans notre méthode `RegisterStudentAsync` comme suit :

###### StudentService.cs

```csharp
public ValueTask<Student> RegisterStudentAsync(Student student) =>
TryCatch(async () =>
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
});
```

En un coup d'œil, vous remarquerez que notre méthode ici ne gère pas nécessairement tout type d'exceptions au niveau logique. C'est parce que tout le bruit d'exception est également extrait dans une méthode appelée `TryCatch`.

`TryCatch` est un concept que j'ai inventé pour permettre aux ingénieurs de se concentrer sur ce qui compte le plus en fonction de l'aspect du service qui les regarde sans avoir à prendre de raccourcis avec la gestion des exceptions pour rendre le code un peu plus lisible.

Les méthodes `TryCatch` vivent généralement dans une autre classe partielle et dans un tout nouveau fichier appelé `StudentService.Exceptions.cs` - où se produisent toutes les exceptions et les rapports d'erreurs, comme je vais vous le montrer dans l'exemple suivant.

Voyons à quoi ressemble une méthode `TryCatch` :

###### StudentService.Exceptions.cs

```csharp
private delegate ValueTask<Student> ReturningStudentFunction();

private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
{
	try
	{
		return await returningStudentFunction();
	}
	catch (InvalidStudentException invalidStudentInputException)
	{
		throw CreateAndLogValidationException(invalidStudentInputException);
	}
}

private StudentValidationException CreateAndLogValidationException(Exception exception)
{
	var studentValidationException = new StudentValidationException(exception);
	this.loggingBroker.LogError(studentValidationException);

	return studentValidationException;
}
```

Le modèle d'annulation de bruit d'exception `TryCatch` prend magnifiquement en compte toute fonction qui renvoie un type particulier en tant que délégué et gère toutes les exceptions levées de cette fonction ou de ses dépendances.

La principale responsabilité d'une fonction `TryCatch` est de regrouper les exceptions internes d'un service avec des exceptions externes pour faciliter la réaction des consommateurs externes de ce service dans une seule des trois catégories, qui sont les exceptions de service, les exceptions de validation et les exceptions de dépendance. . il existe des sous-types à ces exceptions telles que les exceptions de validation de dépendance, mais celles-ci relèvent généralement de la catégorie des exceptions de validation, comme nous le verrons dans les prochaines sections de la norme.

Dans une méthode `TryCatch`, nous pouvons ajouter autant d'exceptions internes et externes que nous le souhaitons et les mapper dans des exceptions locales pour que les services en amont ne dépendent pas fortement de bibliothèques particulières ou de modèles de ressources externes, dont nous parlerons en détail. lorsque nous passons à la responsabilité de cartographie des services de courtage-voisin (fondation).

#### 2.1.3.1.3 Validations logiques

Les validations logiques viennent en second après les validations structurelles. leur responsabilité principale, par définition, est de valider logiquement si une donnée structurellement valide est logiquement valide.
Par exemple, une date de naissance pour un étudiant pourrait être structurellement valide en ayant une valeur de `1/1/1800` mais logiquement, un étudiant qui a plus de 200 ans est une impossibilité.

Les validations logiques les plus courantes sont les validations pour les champs d'audit tels que `CreatedBy` et `UpdatedBy` - il est logiquement impossible qu'un nouvel enregistrement puisse être inséré avec deux valeurs différentes pour les auteurs de ce nouvel enregistrement - simplement parce que les données ne peuvent être insérées que par une personne à la fois.

Parlons de la façon dont nous pouvons tester et implémenter des validations logiques :

##### 2.1.3.1.3.0 Tester les validations logiques

Dans le cas courant de test de validations logiques pour les champs d'audit, nous voulons lever une exception de validation indiquant que la valeur `UpdatedBy` n'est pas valide simplement parce qu'elle ne correspond pas au champ `CreatedBy`.

Supposons que notre modèle Student se présente comme suit :

```csharp
public class Student {
	Guid CreatedBy {get; set;}
	Guid UpdatedBy {get; set;}
}
```

Notre test pour valider ces valeurs serait logiquement le suivant :

```csharp
[Fact]
public async Task ShouldThrowValidationExceptionOnRegisterIfUpdatedByNotSameAsCreatedByAndLogItAsync()
{
	// given
	Student randomStudent = CreateRandomStudent();
	Student inputStudent = randomStudent;
	inputStudent.UpdatedBy = Guid.NewGuid();

	var invalidStudentException = new InvalidStudentException();

	invalidStudentException.AddData(
		key: nameof(Student.UpdatedBy),
		value: $"Id is not the same as {nameof(Student.CreatedBy)}.");

	var expectedStudentValidationException =
		new StudentValidationException(invalidStudentException);

	// when
	ValueTask<Student> registerStudentTask =
		this.studentService.RegisterStudentAsync(inputStudent);

	StudentValidationException actualStudentValidationException =
		await Assert.ThrowsAsync<StudentValidationException>(
			registerStudentTask.AsTask);

	// then
	actualStudentValidationException.Should().BeEquivalentTo(
		expectedStudentValidationException);

	this.loggingBrokerMock.Verify(broker =>
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentValidationException))),
				Times.Once);

	this.storageBrokerMock.Verify(broker =>
		broker.InsertStudentAsync(It.IsAny<Student>()),
			Times.Never);

	this.loggingBrokerMock.VerifyNoOtherCalls();
	this.dateTimeBrokerMock.VerifyNoOtherCalls();
	this.storageBrokerMock.VerifyNoOtherCalls();
}
```

Dans le test ci-dessus, nous avons modifié la valeur du champ `UpdatedBy` pour nous assurer qu'il diffère complètement du champ `CreatedBy` - maintenant nous nous attendons à ce qu'une `InvalidStudentException` avec `CreatedBy` soit la raison pour laquelle cette exception de validation se produit .

Continuons et écrivons une implémentation pour ce test défaillant.

##### 2.1.3.1.3.1 Implémentation des validations logiques

Tout comme nous l'avons fait dans la section des validations structurelles, nous allons ajouter plus de règles à notre `switch case` de validation comme suit :

###### StudentService.Validations.cs

```csharp
private void ValidateStudent(Student student)
{
	Validate(
		(Rule: IsNotSame(
			firstId: student.UpdatedBy,
			secondId: student.CreatedBy,
			secondIdName: nameof(student.CreatedBy)),
		Parameter: nameof(Student.UpdatedBy))
	);
}

private static dynamic IsNotSame(
	Guid firstId,
	Guid secondId,
	string secondIdName) => new
	{
		Condition = firstId != secondId,
		Message = $"Id is not the same as {secondIdName}."
	};

private void Validate(params (dyanamic Rule, string Parameter)[] validations)
{
	var invalidStudentException = new Exception();

	foreach((dynamic rule, string parameter) in validations)
	{
		if(rule.Condition)
		{
			invalidStudentException.UpsertData(
				key: parameter,
				value: rule.Message);
		}
	}
}
```

Tout le reste dans `StudentService.cs` et `StudentService.Exceptions.cs` continue d'être exactement le même que ce que nous avons fait ci-dessus dans les validations structurelles.

Les exceptions de validations logiques, comme toutes les autres exceptions qui peuvent se produire, ne sont généralement pas critiques. Cependant, tout dépend de votre analyse de rentabilisation pour déterminer si une validation logique, structurelle ou même de dépendance particulière est critique ou non, c'est à ce moment que vous devrez peut-être créer une classe spéciale d'exceptions, quelque chose comme `InvalidStudentCriticalException` puis enregistrez-le en conséquence.

#### 2.1.3.1.4 Validations externes

Le dernier type de validations généralement effectuées par les services de la fondation est les validations externes. Je définis les validations externes comme toute forme de validation qui nécessite d'appeler une ressource externe pour valider si un service de base doit poursuivre le traitement des données entrantes ou s'arrêter avec une exception.

Un bon exemple de validation de dépendance est lorsque nous appelons un broker pour récupérer une entité particulière par son identifiant. Si l'entité renvoyée est introuvable ou si le broker d'API renvoie une erreur `NotFound`, le service de base doit alors envelopper cette erreur dans une `ValidationException` et arrête tous les processus suivants.

Des exceptions de validation externes peuvent se produire si la valeur renvoyée ne correspond pas à l'attente, comme une liste vide renvoyée par un appel d'API lors de la tentative d'insertion d'un nouveau coach d'une équipe - s'il n'y a pas de membres de l'équipe, il ne peut y avoir de coach par exemple . Dans ce cas, le service de base devra déclencher une exception locale pour expliquer le problème, quelque chose comme `NoTeamMembersFoundException` ou quelque chose de ce genre.

Écrivons un test d'échec pour un exemple de validation externe :

##### 2.1.3.1.4.0 Tester les validations externes

Supposons que nous essayons de récupérer un étudiant avec un `Id` qui ne correspond à aucun enregistrement dans la base de données. Voici comment nous procéderions pour tester ce scénario. Tout d'abord, définissons un modèle `NotFoundStudentException` comme suit:

```csharp
using Xeption;

public class NotFoundStudentException : Xeption
{
	public NotFoundStudentException(Guid id)
		: base (message: $"Couldn't find a student with id: {id}.")
	{}
}
```

Le modèle ci-dessus est l'aspect localisation de la gestion du problème. Écrivons maintenant un test d'échec comme suit :

```csharp
public async Task ShouldThrowValidationExceptionOnRetrieveByIdIfStudentNotFoundAndLogItAsync()
{
	// given
	Guid randomStudentId = Guid.NewGuid();
	Guid inputStudentId = randomStudentId;
	Student noStudent = null;

	var notFoundStudentException =
		new NotFoundStudentException(inputStudentId);

	var expectedStudentValidationException =
		new StudentValidationException(notFoundStudentException);

	this.storageBrokerMock.Setup(broker =>
		broker.SelectStudentByIdAsync(inputStudentId))
			.ReturnsAsync(noStudent);

	// when
	ValueTask<Student> retrieveStudentByIdTask =
		this.studentService.RetrieveStudentByIdAsync(inputStudentId);

	StudentValidationException actualStudentValidationException =
		await Assert.ThrowsAsync<StudentValidationException>(
			retrieveStudentByIdTask.AsTask);

	// then
	actualStudentValidationException.Should().BeEquivalentTo(
		expectedStudentValidationException);

	this.storageBrokerMock.Verify(broker =>
		broker.SelectStudentByIdAsync(inputStudentId),
			Times.Once);

	this.loggingBrokerMock.Verify(broker =>
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentValidationException))),
				Times.Once);

	this.storageBrokerMock.VerifyNoOtherCalls();
	this.loggingBrokerMock.VerifyNoOtherCalls();
	this.dateTimeBrokerMock.VerifyNotOtherCalls();
}
```

Le test ci-dessus nous oblige à lever une exception localisée comme dans `NotFoundStudentException` lorsque le broker de stockage ne renvoie aucune valeur pour le `studentId` donné, puis à l'envelopper ou à le catégoriser dans `StudentValidationException`.

Nous choisissons d'envelopper l'exception localisée dans une exception de validation et non dans une exception de validation de dépendance car l'origine de l'erreur provient de notre service et non de la ressource externe. Si la ressource externe est la source de l'erreur, nous devrons la catégoriser comme une `DependencyValidationException` dont nous parlerons sous peu.

Passons maintenant à la partie implémentation de cette section pour réussir notre test.

##### 2.1.3.1.4.1 Implémentation de validations externes

Afin de mettre en œuvre une validation externe, nous devrons aborder tous les différents aspects de notre service. La logique de base, la validation et les aspects de gestion des exceptions sont les suivants.

Tout d'abord, construisons une fonction de validation qui lèvera une `NotFoundStudentException` si le paramètre passé est nul.

###### StudentService.Validations.cs

```csharp
private static void VerifyStudentExists(Student maybeStudent, Guid studentId)
{
	if (maybeStudent is null)
	{
		throw new NotFoundStudentException(studentId);
	}
}
```

Cette implémentation se chargera de détecter un problème et d'émettre une exception locale `NotFoundStudentException`. Passons maintenant à l'aspect de gestion des exceptions de notre service.

###### StudentService.Exceptions.cs

```csharp
private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
{
	try
	{
		return await returningStudentFunction();
	}
	..
	catch (NotFoundStudentException notFoundStudentException)
	{
		throw CreateAndLogValidationException(notFoundStudentException);
	}
}

private StudentValidationException CreateAndLogValidationException(Exception exception)
{
	var studentValidationException = new StudentValidationException(exception);
	this.loggingBroker.LogError(studentValidationException);

	return studentValidationException;
}
```

L'implémentation ci-dessus se chargera de catégoriser une `NotFoundStudentException` en `StudentValidationException`. La dernière partie consiste à assembler les pièces comme suit.

###### StudentService.cs

```csharp
public ValueTask<Student> RetrieveStudentByIdAsync(Guid studentId) =>
TryCatch(async () =>
{
	ValidateStudentId(studentId);

	Student maybeStudent =
		await this.storageBroker.SelectStudentByIdAsync(studentId);

	ValidateStudentExists(maybeStudent, studentId);

	return maybeStudent;
});
```

L'implémentation ci-dessus garantira que l'identifiant est valide, mais plus important encore, tout ce que le `storageBroker` renvoie sera vérifié s'il s'agit d'un objet ou de `null`. Émettez ensuite l'exception.

Il existe des situations où tenter de récupérer une entité puis découvrir qu'elle n'existe pas n'est pas nécessairement erroné. C'est là que les services de traitement interviennent pour tirer parti d'une logique métier d'ordre supérieur pour faire face à ce scénario plus complexe.

#### 2.1.3.1.5 Validations de dépendance

Des exceptions de validation de dépendance peuvent se produire parce que vous avez appelé une ressource externe et qu'elle a renvoyé une erreur, ou a renvoyé une valeur qui justifie le déclenchement d'une erreur. Par exemple, un appel API peut renvoyer un code `404`, et cela est interprété comme une exception si l'entrée était censée correspondre à un objet existant.

Un exemple plus courant est lorsqu'une entité d'entrée particulière utilise le même identifiant qu'une entité existante dans le système. Dans un monde de base de données relationnelle, une exception de clé en double serait levée. Dans un scénario d'API RESTful, l'application par programmation du même concept atteint également le même objectif pour les validations d'API en supposant que la granularité du système appelé affaiblit l'intégrité référentielle des données système globales.

Il existe des situations où la réponse erronée peut être exprimée d'une manière autre que des exceptions, mais nous aborderons ce sujet dans des chapitres plus avancés de cette norme.

Écrivons un test d'échec pour vérifier si nous lançons une `DependencyValidationException` si le modèle `Student` existe déjà dans le stockage avec le broker de stockage lançant une `DuplicateKeyException` comme résultat natif de l'opération.

##### 2.1.3.1.5.0 Tester les validations de dépendance

Notre test unitaire pour valider une exception `DependencyValidation` serait lancée dans une situation `DuplicateKey` serait la suivante :

```csharp
public class Student
{
	public Guid Id {get; set;}
	public string Name {get; set;}
}
```

notre test unitaire pour valider une exception `DependencyValidation` serait lancée dans une situation `DuplicateKey` serait la suivante :

```csharp
[Fact]
public async void ShouldThrowDependencyValidationExceptionOnRegisterIfStudentAlreadyExistsAndLogItAsync()
{
	// given
	Student someStudent = CreateRandomStudent();
	string someMessage = GetRandomMessage();
	var duplicateKeyException = new DuplicateKeyException(exceptionMessage);

	var alreadyExistsStudentException =
		new AlreadyExistsStudentException(duplicateKeyException);

	var expectedStudentDependencyValidationException =
		new StudentDependencyValidationException(alreadyExistsStudentException);

	this.storageBrokerMock.Setup(broker =>
		broker.InsertStudentAsync(It.IsAny<Student>()))
			.ThrowsAsync(duplicateKeyException);

	// when
	ValueTask<Student> registerStudentTask =
		this.studentService.RegisterStudentAsync(inputStudent);

	StudentDependencyValidationException actualStudentDependencyValidationException =
		await Assert.ThrowsAsync<StudentDependencyValidationException>(
			registerStudentTask.AsTask);

	// then
	actualStudentDependencyValidationException.Should().BeEquivalentTo(
		expectedStudentDependencyValidationException);

	this.storageBrokerMock.Verify(broker =>
		broker.InsertStudentAsync(It.IsAny<Student>()),
			Times.Once);

	this.loggingBrokerMock.Verify(broker =>
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentDependencyValidationException))),
				Times.Once);

	this.storageBrokerMock.VerifyNoOtherCalls();
	this.loggingBrokerMock.VerifyNoOtherCalls();
}
```

Dans le test ci-dessus, nous validons que nous encapsulons une `DuplicateKeyException` native dans un modèle local adapté au cas de modèle spécifique qui est `AlreadyExistsStudentException` dans notre exemple ici. puis nous l'enveloppons à nouveau avec un modèle d'exception de catégorie générique qui est `StudentDependencyValidationException`.

Il existe quelques règles qui régissent la construction des validations de dépendance, qui sont les suivantes :

- Règle 1 : si une validation de dépendance gère une autre validation de dépendance à partir d'un service en aval, l'exception interne de l'exception en aval doit être la même pour la validation de dépendance au niveau actuel.

En d'autres termes, si un `StudentService` lance une `StudentDependencyValidationException` à un service en amont tel que `StudentProcessingService` - alors il est important que `StudentProcessingDependencyValidationException` contienne la même exception interne que `StudentDependencyValidationException`. En effet, une fois ces exceptions mappées dans des composants d'exposition, tels que le contrôleur d'API ou les composants d'interface utilisateur, le message de validation d'origine doit se propager dans le système et être présenté à l'utilisateur final, quelle que soit son origine.

De plus, le maintien de l'exception interne d'origine garantit la possibilité de communiquer différents messages d'erreur via les points de terminaison de l'API. Par exemple, `AlreadyExistsStudentException` peut être communiqué en tant que `Conflict` ou `409` au niveau du contrôleur d'API - cela diffère d'une autre exception de validation de dépendance telle que `InvalidStudentReferenceException` qui serait communiquée en tant qu'erreur `FailedDependency` ou `424`.

- Règle 2 : si une exception de validation de dépendance gère une exception de validation de non-dépendance, elle doit considérer cette exception comme une exception interne et rien d'autre.

Ces règles garantissent que seule l'exception de validation locale est propagée et non l'exception native d'un système de stockage ou d'une API ou de toute autre dépendance externe.

C'est le cas que nous avons ici avec notre `AlreadyExistsStudentException` et c'est `StudentDependencyValidationException` - l'exception native est complètement cachée, et le mappage de cette exception native et son message interne est ce qui est communiqué à l'utilisateur final. Cela donne aux ingénieurs le pouvoir de contrôler ce qui est communiqué depuis l'autre extrémité de leur système au lieu de laisser le message natif (qui est sujet à changement) se propager aux utilisateurs finaux.

##### 2.1.3.0.5.1 Implémentation des validations de dépendance

Selon l'origine de l'erreur de validation, l'implémentation des validations de dépendance peut contenir ou non une logique métier. Comme nous l'avons mentionné précédemment, si l'erreur provient de la ressource externe (ce qui est le cas ici) - alors tout ce que nous avons à faire est simplement d'envelopper cette erreur dans une exception locale puis de la catégoriser avec une exception externe sous validation de dépendance.

Pour garantir la réussite du test susmentionné, nous aurons besoin de quelques modèles.
Pour `AlreadyExistsStudentException`, l'implémentation serait la suivante :

```csharp
public class AlreadyExistsStudentException : Exception
{
	public AlreadyExistsStudentException(Exception innerException)
		: base($"Student with the same Id already exists", innerException){ }
}
```

Nous avons également besoin de `StudentDependencyValidationException` qui devrait être comme suit :

```csharp
public class StudentDependencyValidationException : Exception
{
	public StudentDependencyValidationException(Exception innerException)
		: base($"Student dependency validation error occurred, please try again.", innerException){ }
}

```

Passons maintenant au côté de l'implémentation, commençons par la logique de gestion des exceptions :

###### StudentService.Exceptions.cs

```csharp
private delegate ValueTask<Student> ReturningStudentFunction();

private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
{
	try
	{
		return await returningStudentFunction();
	}
	...
	catch (DuplicateKeyException duplicateKeyException)
	{
		var alreadyExistsStudentException = new AlreadyExistsStudentException(duplicateKeyException);
		throw CreateAndLogDependencyValidationException(alreadyExistsStudentException);
	}
}

...

private StudentDependencyValidationException CreateAndLogDependencyValidationException(Exception exception)
{
	var studentDependencyValidationException = new StudentDependencyValidationException(exception);
	this.loggingBroker.LogError(studentDependencyValidationException);

	return studentDependencyValidationException;
}
```

Nous avons créé l'exception interne locale dans le bloc catch de notre processus de gestion des exceptions pour permettre la réutilisation de notre méthode d'exception de validation des dépendances pour d'autres situations nécessitant le même niveau d'exceptions externes.

Tout le reste reste le même pour le référencement de la méthode `TryCatch` dans le fichier `StudentService.cs`.

### 2.1.3.2 Mappage

La deuxième responsabilité d'un service de base est de jouer le rôle d'un mappeur dans les deux sens entre les modèles locaux et les modèles non locaux. Par exemple, si vous exploitez un service de messagerie qui fournit ses propres SDK à intégrer, et que vos courtiers encapsulent et exposent déjà les API pour ce service, votre service de base doit mapper les entrées et les sorties des méthodes de broker en local des modèles. la même situation et plus communément entre les exceptions natives non locales telles que celles que nous avons mentionnées ci-dessus avec la situation de validation des dépendances, le même aspect s'applique uniquement aux erreurs de dépendance ou aux erreurs de service, comme nous le verrons bientôt.

#### 2.1.3.2.0 Modèles non locaux

Il est très courant que les applications modernes nécessitent une intégration à un moment donné avec des services externes. ces services peuvent être locaux à l'architecture globale ou au système distribué où réside l'application, ou il peut s'agir d'un fournisseur tiers tel que certains des services de messagerie populaires par exemple.
Les fournisseurs de services externes investissent beaucoup d'efforts dans le développement d'API, de SDK et de bibliothèques fluides dans tous les langages de programmation courants pour permettre aux ingénieurs d'intégrer facilement leurs applications à ce service tiers. Par exemple, supposons qu'un fournisseur de services de messagerie tiers propose l'API suivante via ses SDK :

```csharp
public interface IEmailServiceProvider
{
	ValueTask<EmailMessage> SendEmailAsync(EmailMessage message);
}
```

Considérons que le modèle `EmailMessage` est un modèle natif, il est fourni avec le SDK du fournisseur de services de messagerie. vos courtiers peuvent proposer un wrapper autour de cette API en créant un contrat pour extraire la _fonctionnalité_ mais ne peuvent pas faire grand-chose avec les modèles natifs qui sont transmis ou renvoyés par ces fonctionnalités. par conséquent, l'interface de nos courtiers ressemblerait à ceci :

```csharp
public interface IEmailBroker
{
	ValueTask<EmailMessage> SendEmailMessageAsync(EmailMessage message);
}
```

Ensuite, l'implémentation ressemblerait à ceci :

```csharp
public class EmailBroker : IEmailBroker
{
	public async ValueTask<EmailMessage> SendEmailMessageAsync(EmailMessage message) =>
		await this.emailServiceProvider.SendEmailAsync(message);
}
```

Comme nous l'avons déjà dit, les courtiers ici ont fait leur part d'abstraction en repoussant l'implémentation réelle et les dépendances du "EmailServiceProvider" natif de nos services de base. Mais ce n'est que 50 % du travail, l'abstraction n'est pas encore complètement terminée tant qu'il n'y a pas de traces du modèle natif `EmailMessage`. C'est là que les services de base interviennent pour effectuer une opération de mappage pilotée par des tests entre les modèles natifs non locaux et les modèles locaux de votre application. il est donc très possible de voir une fonction de mappage dans un service de base pour extraire le modèle natif du reste de vos services de couche métier.

Votre service de base devra alors prendre en charge un nouveau modèle local, appelons-le `Email`. la propriété de votre modèle local peut être identique au modèle externe `EmailMessage` - en particulier au niveau du type de données primitif. Mais le nouveau modèle serait le seul et unique contrat entre votre couche de logique métier pure (services de traitement, d'orchestration, de coordination et de gestion) et votre couche de logique hybride comme les services de base. Voici un extrait de code pour cette opération :

```csharp
public async ValueTask<Email> SendEmailMessageAsync(Email email)
{
	EmailMessage inputEmailMessage = MapToEmailMessage(email);
	EmailMessage sentEmailMessage = await this.emailBroker.SendEmailMessageAsync(inputEmailMessage);

	return MapToEmail(sentEmailMessage);
}

```

Selon que le message renvoyé a un statut ou que vous souhaitiez renvoyer le message d'entrée comme signe d'une opération réussie, les deux pratiques sont valables dans my Standard. Tout dépend de ce qui a le plus de sens pour l'opération que vous essayez d'exécuter. l'extrait de code ci-dessus est un scénario idéal dans lequel votre code essaiera de rester fidèle à la valeur transmise ainsi qu'à la valeur renvoyée avec tout le mappage nécessaire inclus.

#### 2.1.3.2.1 Mappages d'exceptions

Tout comme les modèles non locaux, les exceptions produites par l'API externe comme les modèles EntityFramework `DbUpdateException` ou tout autre doivent être mappées dans des modèles d'exception locaux.
La gestion de ces exceptions non locales tôt avant d'entrer dans les composants de la couche métier pure empêchera tout couplage étroit potentiel ou toute dépendance vis-à-vis d'un modèle externe. comme cela peut être très courant, les exceptions peuvent être gérées différemment en fonction du type d'exception et de la manière dont nous voulons la traiter en interne dans le système.
Par exemple, si nous essayons de gérer une `UserNotFoundException` levée à partir de l'utilisation de Microsoft Graph par exemple, nous ne voudrons peut-être pas nécessairement quitter la procédure entière. nous voudrons peut-être continuer en ajoutant un utilisateur dans un autre stockage pour le futur traitement de soumission de Graph.
Les API externes ne doivent pas influencer si votre opération interne doit s'arrêter ou non. et par conséquent, la gestion des exceptions sur la couche Foundation est la garantie que cette influence est limitée dans les limites de notre zone de gestion des ressources externes de notre application et n'a aucun impact sur nos processus métier de base.
L'illustration suivante devrait rendre l'image un peu plus claire de ce point de vue :
<br />

<p align=center>
<img src="https://user-images.githubusercontent.com/1453985/112714067-b7366a00-8e95-11eb-9bb7-a5a047640f4a.png" />
</p>
<br />

Voici quelques scénarios courants pour mapper des exceptions locales natives ou internes à des exceptions externes :

| Exception                             | Wrap Inner Exception With        | Wrap With                            | Log Level |
| ------------------------------------- | -------------------------------- | ------------------------------------ | --------- |
| NullStudentException                  | -                                | StudentValidationException           | Error     |
| InvalidStudentException               | -                                | StudentValidationException           | Error     |
| SqlException                          | FailedStudentStorageException    | StudentDependencyException           | Critical  |
| HttpResponseUrlNotFoundException      | FailedStudentApiException        | StudentDependencyException           | Critical  |
| HttpResponseUnauthorizedException     | FailedStudentApiException        | StudentDependencyException           | Critical  |
| NotFoundStudentException              | -                                | StudentValidationException           | Error     |
| HttpResponseNotFoundException         | NotFoundStudentException         | StudentDependencyValidationException | Error     |
| DuplicateKeyException                 | AlreadyExistsStudentException    | StudentDependencyValidationException | Error     |
| HttpResponseConflictException         | AlreadyExistsStudentException    | StudentDependencyValidationException | Error     |
| ForeignKeyConstraintConflictException | InvalidStudentReferenceException | StudentDependencyValidationException | Error     |
| DbUpdateConcurrencyException          | LockedStudentException           | StudentDependencyValidationException | Error     |
| DbUpdateException                     | FailedStudentStorageException    | StudentDependencyException           | Error     |
| HttpResponseException                 | FailedStudentApiException        | StudentDependencyException           | Error     |
| Exception                             | FailedStudentServiceException    | StudentServiceException              | Error     |

[*] [Standardisation des validations et des exceptions](https://www.youtube.com/watch?v=Wtpxb7yPQP0)

[*] [Tester des validations Non-Circuit-Breaking](https://www.youtube.com/watch?v=guJPrIQ0kJk)
