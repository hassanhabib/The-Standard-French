# 2 Services

## 2.0 Introduction

Les services en général sont les conteneurs de toute la logique métier dans un logiciel donné - ils sont le composant central de tout système et le principal élément qui fait qu'un système est différent d'un autre.

Notre objectif principal avec les services est de les garder complètement agnostiques des technologies specific ou des dépendances externes.

Toute couche métier est plus conforme à la norme si elle peut être branchée sur toutes les autres dépendances et technologies d'exposition avec le moins d'efforts d'intégration possible.

### 2.0.0 Opérations de services

Lorsque nous parlons de logique métier, nous nous référons principalement à trois grandes catégories d'opérations, à savoir la validation, le traitement et l'intégration.

<br />
<p align=center>
    <img src="https://user-images.githubusercontent.com/1453985/100530065-4494d680-31a2-11eb-8393-32b21ab99a3d.png" />
</p>
<br />

Parlons de ces catégories alors:

#### 2.0.0.0 Validations

Les validations visent à garantir que les données entrantes ou sortantes correspondent à un ensemble particulier de règles, qui peuvent être des validations structurelles, logiques ou externes, dans cet ordre exact de priorité. Nous reviendrons en détail sur ce sujet dans les sections suivantes.

#### 2.0.0.1 Processing

Le processing (traitement) se concentre principalement sur le flow-control, la cartographie et le calcul pour satisfaire un besoin métier - les opérations de traitement sont spécificalement ce qui distingue un service d'un autre, et en général un logiciel d'un autre.

#### 2.0.0.2 Intégration

Enfin, le processus d'intégration est principalement axé sur la récupération ou le transfert de données depuis ou vers les dépendances du système intégré.

Chacun de ces aspects sera abordé en détail dans le chapitre suivant, mais la principale chose à comprendre à propos des services est qu'ils doivent être construits avec l'intention d'être pluggables et configurables afin qu'ils soient facilement intégrés à n'importe quelle technologie du point de vue des dépendances et qu'ils puissent également être facilement branchés à n'importe quelle fonctionnalité d'exposition du point de vue des API.

### 2.0.1 Types de services

Mais les services ont plusieurs types en fonction de leur place dans une architecture donnée, ils se répartissent en trois grandes catégories, à savoir : les validateurs, les orchestrateurs et les agrégateurs.

<br />
<p align=center>
 <img src="https://user-images.githubusercontent.com/1453985/100529444-b23e0400-319c-11eb-816a-59c73154542b.png" />
</p>
<br />

#### 2.0.1.0 Validateurs

Les services de validation sont principalement les services de broker-voisin ou les services de fondation.

La principale responsabilité de ces services est d'ajouter une couche de validation au-dessus des opérations primitives existantes, telles que les opérations CRUD, afin de garantir que les données entrantes et sortantes sont validées structurellement, logiquement et extérieurement avant d'être envoyées dans ou hors du système.

#### 2.0.1.1 Orchestrateurs

Les services d'orchestration sont au coeur de la couche de logique métier. Ils peuvent être des processeurs, des orchestrateurs, des coordinateurs ou des services de gestion, selon le type de leurs dépendances.

Les services d'orchestration se concentrent principalement sur la combinaison de plusieurs opérations primitives ou de plusieurs opérations de logique commerciale de haut niveau pour atteindre un objectif encore plus élevé.

Les services d'orchestration sont les décideurs au sein de toute architecture, ils sont les propriétaires du flow-control dans tout système et ils sont le principal composant qui rend une application ou un logiciel different des autres.

Les services Orchestrator sont également destinés à être construits et à vivre plus longtemps que tout autre type de services dans le système.

#### 2.0.1.2 Agrégateurs

La principale responsabilité des services d'agrégation est de lier les résultats de plusieurs services de traitement, d'orchestration, de coordination ou de gestion afin d'exposer une seule API pour qu'un contrôleur d'API donné ou un composant d'interface utilisateur puisse interagir avec le reste du système.

Les agrégateurs sont les gardiens de la couche de logique métier, ils garantissent que les composants d'exposition des données (comme les contrôleurs d'API) n'ont qu'un seul point de contact pour interagir avec le reste du système.

En général, les agrégateurs ne se soucient pas vraiment de l'ordre dans lequel ils appellent les opérations qui leur sont attachées, mais il devient parfois nécessaire d'exécuter une opération particulière, comme créer une fiche d'étudiant avant de lui attribuer une carte de bibliothèque.

Nous examinerons en détail chacun de ces types de services dans les chapitres suivants.

### 2.0.2 Règles générales

Plusieurs règles régissent l'architecture globale et la conception des services dans tout système.

Ces règles assurent la lisibilité, la maintenabilité, la configurabilité globale du système - dans cet ordre particulier.

#### 2.0.2.0 Faire ou déléguer

Chaque service doit soit faire le travail, soit déléguer le travail, mais pas les deux.

Par exemple, un service de traitement devrait déléguer le travail de persistance des données à un service de fondation et ne pas essayer de faire ce travail lui-même.

#### 2.0.2.1 Deux-trois (Florance Pattern)

Pour les services Orchestrator, leurs dépendances de services (pas de brokers) devraient être limitées à 2 ou 3 mais pas 1 et pas 4 ou plus.

La dépendance à un seul service nie la définition même de l'orchestration. En effet, par définition, l'orchestration est la combinaison entre plusieurs opérations différentes provenant de sources differentes pour atteindre un ordre supérieur de logique d'entreprise.

###### Ce pattern viole le Florance Pattern

<br/>
<p align=center>
    <img src="https://user-images.githubusercontent.com/1453985/100561648-4926c100-326e-11eb-9028-96bcd3eb0b1d.png">
</p>
<br />

###### Ce pattern suit la symétrie du Pattern

<br />
<p align=center>
    <img src="https://user-images.githubusercontent.com/1453985/100561978-2a74fa00-326f-11eb-9d05-404eed3eaf5f.png">
</p>
<br />

Le motif Florance assure également l'équilibre et la symétrie de l'architecture globale.

Par exemple, vous ne pouvez pas orchestrer entre un service de fondation et un service de traitement, cela provoque une forme de déséquilibre dans votre architecture, et une perturbation malaisée en essayant de combiner un énoncé unifié avec le langage que chaque service parle en fonction de son niveau et de son type.

Le seul type de services qui peut enfreindre cette règle est celui des agrégateurs, où la combinaison et l'ordre des services ou de leurs appels n'ont pas d'impact réel.

Nous aborderons le modèle Florance un peu plus en détail dans les prochaines sections du Standard.

#### 2.0.2.2 Point d'exposition unique

Les contrôleurs d'API, les composants d'interface utilisateur ou toute autre forme d'exposition aux données du système doivent avoir un point de contact unique avec la couche logique de l'entreprise.

Par exemple, un point de terminaison d'API qui offerait des points de terminaison pour la persistance et la récupération des données des étudiants, ne devrait pas avoir plusieurs intégrations avec plusieurs services, mais plutôt un seul service qui offers toutes ces fonctionnalités.

Parfois, un seul service d'orchestration, de coordination ou de gestion n'offer tout ce qui concerne une entité particulière, auquel cas un service agrégateur est nécessaire pour combiner toutes ces fonctionnalités en un seul service prêt à être intégré par une technologie d'exposition.

#### 2.0.2.3 Identique ou Primitives Modèle E/S

Pour tous les services, ils doivent maintenir un contrat unique en termes de types de retour et d'entrée, sauf s'il s'agissait de primitives.

Par exemple, un service qui fournit n'importe quel type d'opérations pour un type d'entité `Student` ne doit renvoyer aucun autre type d'entité à partir de l'une de ses méthodes.

Vous pouvez renvoyer une agrégation de la même entité, qu'elle soit personnalisée ou native, comme les modèles `List<Student>` ou `AggregatedStudents`, ou un type primitif comme obtenir le nombre d'étudiants, ou un booléen indiquant si un étudiant existe ou non, mais pas n'importe lequel autre contrat non primitif ou non groupant.

Pour les paramètres d'entrée, une règle similaire s'applique - tout service peut recevoir un paramètre d'entrée du même contrat ou un contrat d'agrégation virtuelle ou un type primitif mais pas n'importe quel autre contrat, qui viole simplement la règle.

Cette règle met l'accent sur tout service pour maintenir sa responsabilité sur une seule entité et toutes ses opérations connexes.

Une fois qu'un service renvoie un contrat différent, il viole simplement sa propre convention de dénomination comme un `StudentOrchestrationService` renvoyant `List<Teacher>` - et il commence à tomber dans le piège d'être appelé par d'autres services à partir de pipelines de données complètement différents.

Pour les paramètres d'entrée primitifs, s'ils appartiennent à un modèle d'entité différent, qui n'est pas nécessairement une référence sur l'entité principale, il se pose la question d'orchestrer entre deux services de traitement ou de fondation pour maintenir un modèle unifié sans enfreindre la règle de la pure contractualisation.

Si la combinaison entre plusieurs contrats différents dans un service d'orchestration est requise, un nouveau modèle virtuel unifié doit être le nouveau contrat unique pour le service d'orchestration avec des mappages implémentés en dessous au niveau concret de ce service pour maintenir la compatibilité et la sécurité de l'intégration.

#### 2.0.2.4 Chaque service pour lui-même

Chaque service est responsable de la validation de ses entrées et de ses sorties. Vous ne devez pas compter sur des services en amont ou en aval pour valider vos données.

Il s'agit d'un mécanisme de programmation défensif pour garantir qu'en cas d'échange d'implémentations derrière des contrats, la responsabilité d'un service donné ne serait pas affectée si des services en aval ou en amont décidaient de transmettre leurs validations pour une raison quelconque.

Dans tout système basé sur une architecture monolithique, microservice ou sans serveur, chaque service est construit avec l'intention de se séparer du système à un moment donné et de devenir le dernier point de contact avant l'intégration avec un broker de ressources externe.

Par exemple, dans l'architecture suivante, les services mappent des parties d'un modèle d'entrée `Student` dans un modèle `LibraryCard`. Voici un visuel des modèles :

###### Student

```csharp
public class Student
{
    public Guid Id {get; set;}
    public string Name {get; set;}
}
```

###### LibraryCard

```csharp
public class LibraryCard
{
    public Guid Id {get; set;}
    public Guid StudentId {get; set;}
}
```

Maintenant, supposons que notre service d'orchestrateur `StudentOrchestrationService` s'assure que chaque nouvel étudiant qui s'inscrit devra avoir une carte de bibliothèque, donc notre logique peut ressembler à ceci :

```csharp
public async ValueTask<Student> RegisterStudentAsync(Student student)
{
    Student registeredStudent =
        await this.studentProcessingService.RegisterStudentAsync(student);

    await AssignStudentLibraryCardAsync(student);

    return registeredStudent;
}

private async ValueTask<LibraryCard> AssignStudentLibraryCardAsync(Student student)
{
    LibraryCard studentLibraryCard = MapToLibraryCard(student);

    return await this.libraryCardProcessingService.AddLibraryCardAsync(studentLibraryCard);
}

private LibraryCard MapToLibraryCard(Student student)
{
    return new LibraryCard
    {
        Id = Guid.NewGuid(),
        StudentId = student.Id
    };
}
```

Comme vous pouvez le voir ci-dessus, un identifiant d'étudiant valide est requis pour assurer un mappage réussi à une `LibraryCard` - et puisque le mappage est la responsabilité de l'orchestrateur, nous devons nous assurer que l'étudiant d'entrée et son identifiant sont en bon état avant de continuer avec le processus d'orchestration.