# 1 Brokers

## 1.0 Introduction
Les brokers (ou _courtiers_) jouent le rôle de liaison entre la logique métier et le monde extérieur.
Ce sont des emballages autour de toutes les bibliothèques, ressources, services ou API externes pour satisfaire une interface locale permettant à l'entreprise d'interagir avec ces ressources sans avoir à être étroitement couplées à des ressources particulières ou à une implémentation de bibliothèque externe.

Les brokers en général sont censés être jetables et remplaçables - ils sont construits avec la compréhension que la technologie évolue et change tout le temps et donc ils doivent être remplacés à un moment donné dans le cycle de vie d'une application donnée par une technologie moderne qui obtient le travail fait plus vite.

Mais les brockers garantissent également que votre entreprise est enfichable en faisant abstraction de toute dépendance spécifique aux ressources externes de ce que votre logiciel essaie réellement d'accomplir.

Par exemple, supposons que vous disposiez d'une API conçue pour consommer et diffuser des données à partir d'un serveur SQL. À un moment donné, vous avez décidé qu'une meilleure option plus économique pour votre API consiste à s'appuyer sur une technologie NoSql à la place. Avoir un broker pour supprimer la dépendance à SQL facilitera grandement l'intégration simple avec NoSql avec le moins de temps et de coût humainement possible.

## 1.1 Sur la carte
Dans n'importe quelle application donnée, mobile, ordinateur de bureau, Web ou simplement une API - les brokers résident généralement à la "queue" de n'importe quelle application - c'est parce qu'ils sont le dernier point de contact entre notre code personnalisé et le monde extérieur.

Que le monde extérieur dans cette instance soit simplement un stockage local en mémoire ou un système entièrement indépendant qui réside derrière une API, ils doivent tous résider derrière les brokers dans n'importe quelle application.

Dans l'architecture de bas niveau suivante pour une API donnée, les brokers résident entre notre logique métier et la ressource externe :

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/16063715/187032055-2eea1dfa-ab15-42a7-9069-cc3d500a5be3.png" />
    </p>
<br />

## 1.2 Caractéristiques
Il existe quelques règles simples qui régissent la mise en œuvre de tout broker - ces règles sont :

### 1.2.0 Implémente une interface locale
Les brokers doivent satisfaire à un contrat local. ils doivent implémenter une interface locale pour permettre le découplage entre leur implémentation et les services qui les consomment.

Par exemple, étant donné que nous avons un contrat local `IStorageBroker` qui nécessite une implémentation pour toute opération CRUD donnée pour un modèle local `Student` - l'opération de contrat serait la suivante :

```csharp
    public partial interface IStorageBroker
    {
        IQueryable<Student> SelectAllStudents();
    }
```

Une implémentation pour un broker de stockage serait la suivante :

```csharp
    public partial class StorageBroker
    {
        public DbSet<Student> Students { get; set; }

        public IQueryable<Student> SelectAllStudents()
        {
            using var broker = new StorageBroker(this.configuration);

            return broker.Students;
        }
    }
```

Une implémentation de contrat local peut être remplacée à tout moment, de l'utilisation d'Entity Framework comme le montre l'exemple précédent, à l'utilisation d'une technologie complètement différente comme Dapper, ou d'une infrastructure entièrement différente comme une base de données Oracle ou PostgreSQL.

### 1.2.1 Aucun contrôle de flux
Les brokers ne devraient avoir aucune forme de contrôle de flux comme des instructions if, des boucles while ou des cas de commutation - c'est simplement parce que le code de contrôle de flux est considéré comme une logique métier, et il s'adapte mieux à la couche de services où la logique métier ne devrait pas résider les brokers.

Par exemple, une méthode de courtage qui récupère une liste d'étudiants à partir d'une base de données ressemblerait à ceci :

```csharp
    public IQueryable<Student> SelectAllStudents()
    {
        using var broker = new StorageBroker(this.configuration);

        return broker.Students;
    }
```
Une fonction simple qui appelle l'EntityFramework natif `DbSet<T>` et renvoie un modèle local comme `Student`.

### 1.2.2 Aucune gestion des exceptions
La gestion des exceptions est en quelque sorte une forme de contrôle de flux. Les brokers ne sont pas censés gérer les exceptions, mais laissent plutôt l'exception se propager aux services voisins du broker où ces exceptions seront correctement mappées et localisées.

### 1.2.3 Possédent leurs configurations
Les brokers sont également tenus de gérer leurs propres configurations - ils peuvent avoir une injection de dépendance à partir d'un objet de configuration, pour récupérer et configurer les configurations pour n'importe quelle ressource externe avec laquelle ils s'intègrent.

Par exemple, les chaînes de connexion dans les communications de base de données doivent être extraites et transmises au client de base de données pour établir une connexion réussie, comme suit :

```csharp
    public partial class StorageBroker : EFxceptionsContext, IStorageBroker
    {
        private readonly IConfiguration configuration;

        public StorageBroker(IConfiguration configuration)
        {
            this.configuration = configuration;
            this.Database.Migrate();
        }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            string connectionString = this.configuration.GetConnectionString("DefaultConnection");
            optionsBuilder.UseSqlServer(connectionString);
        }
    }
```

### 1.2.4 Natifs dès primitifs
Les brokers peuvent construire un objet de modèle externe basé sur des types primitifs transmis par les services voisins du broker.

Par exemple, dans le broker de notifications par e-mail, les paramètres d'entrée pour une fonction `.Send(...)` par exemple nécessitent les paramètres d'entrée de base tels que le sujet, le contenu ou l'adresse par exemple, voici un exemple :

```csharp
    public async ValueTask SendMailAsync(List<string> recipients, string subject, string content)
    {
        Message message = BuildMessage(recipients, ccRecipients, subject, content);
        await SendEmailMessageAsync(message);
    }
```

Les paramètres d'entrée primitifs garantiront qu'il n'y a pas de fortes dépendances entre les services voisins du broker et les modèles externes.
Même dans les situations où le broker est simplement un point d'intégration entre votre application et une API RESTful externe, il est très fortement recommandé de créer vos propres modèles natifs pour refléter le même objet JSON envoyé ou renvoyé par l'API au lieu de compter sur les bibliothèques de nugets , dll ou projets partagés pour atteindre le même objectif.

### 1.2.5 Conventions de nommage
Les contrats pour les brokers doivent rester aussi génériques que possible pour indiquer la fonctionnalité globale d'un broker, par exemple nous disons `IStorageBroker` au lieu de `ISqlStorageBroker` pour indiquer une technologie ou une infrastructure particulière.

Mais dans le cas d'implémentations concrètes de brokers, tout dépend du nombre de brokers que vous avez offrant des fonctionnalités similaires, en cas d'avoir un seul broker de stockage, il pourrait être plus pratique de conserver le même nom que le contrat - dans notre cas ici un l'implémentation concrète de `IStorageBroker` serait `StorageBroker`.

Cependant, si votre application prend en charge plusieurs files d'attente, stockages ou fournisseurs de services de messagerie, vous devrez peut-être commencer à spécifier la cible globale du composant, par exemple, un `IQueueBroker` aurait plusieurs implémentations telles que `NotificationQueueBroker` et `OrdersQueueBroker` .

Mais si les implémentations concrètes ciblent le même modèle et la même valeur commerciale, un détournement vers la technologie pourrait être plus approprié dans ce cas, par exemple dans le cas d'un `IStorageBroker`, deux implémentations concrètes différentes seraient `SqlStorageBroker` et `MongoStorageBroker` ce cas est très possible dans des situations où les coûts environnementaux sont réduits dans des infrastructures inférieures à la production par exemple.

### 1.2.6 Langage
Les brokers parlent le langage des technologies qu'ils prennent en charge.
Par exemple, dans un broker de stockage, nous disons `SelectById` pour correspondre à l'instruction SQL `Select` et dans un broker de file d'attente, nous disons `Enqueue` pour correspondre à la langue.

Si un broker prend en charge un point de terminaison d'API, il doit suivre le langage d'opérations RESTFul, tel que `POST`, `GET` ou `PUT`, voici un exemple :

```csharp

    public async ValueTask<Student> PostStudentAsync(Student student) =>
        await this.PostAsync(RelativeUrl, student);

```

### 1.2.7 D'en haut & du coté
Les brokers ne peuvent pas appeler d'autres brokers. c'est simplement parce que les brokers sont le premier point d'abstraction, ils ne nécessitent aucune abstraction supplémentaire et aucune dépendance supplémentaire autre qu'un modèle d'accès à la configuration.

Les brokers ne peuvent pas non plus avoir des services en tant que dépendances, car le flux dans un système donné doit provenir des services vers les brokers et non l'inverse.

Même dans les situations où un microservice doit s'abonner à une file d'attente, par exemple, les brokers transmettront une méthode d'écoute pour traiter les événements entrants, mais n'appelleront pas les services qui fournissent la logique de traitement.

La règle générale serait alors que les brokers ne peuvent être appelés que par des services et qu'ils ne peuvent appeler que des dépendances natives externes.

## 1.3 Organisation
Les brokers qui prennent en charge plusieurs entités telles que les brokers de stockage doivent tirer parti des classes partielles pour répartir les responsabilités par entité.

Par exemple, si nous avons un courtier de stockage qui fournit toutes les opérations CRUD pour les modèles `Student` et `Teacher`, l'organisation des fichiers doit être la suivante :

- IStorageBroker.cs
  - IStorageBroker.Students.cs
  - IStorageBroker.Teachers.cs
- StorageBroker.cs
  - StorageBroker.Students.cs
  - StorageBroker.Teachers.cs

L'objectif principal de cette organisation particulière tirant parti des classes partielles est de séparer les préoccupations de chaque entité à un niveau encore plus fin, ce qui devrait rendre la maintenabilité du logiciel beaucoup plus élevée.

Mais la convention de dénomination des fichiers et dossiers des brokers se concentre strictement sur la pluralité des entités qu'ils prennent en charge et sur la singularité de la ressource globale prise en charge.

Par exemple, nous disons `IStorageBroker.Students.cs`. et nous disons également `IEmailBroker` ou `IQueueBroker.Notifications.cs` - singulier pour la ressource et les entités plurielles.

Le même concept s'applique aux dossiers ou espaces de noms contenant ces brokers.

Par exemple, nous disons :

```csharp
namespace OtripleS.Web.Api.Brokers.Storages
{
    ...
}
```

Et nous disons:
```csharp
namespace OtripleS.Web.Api.Brokers.Queues
{
    ...
}
```

## 1.4 Types de brokers
Dans la plupart des applications construites aujourd'hui, il existe des brokers courants qui sont généralement nécessaires pour faire fonctionner une application d'entreprise - certains de ces brokers sont comme le stockage, le temps, les API, la journalisation et les files d'attente.

Certains de ces brokers interagissent avec les ressources existantes sur le système, telles que le temps, pour permettre aux services voisins du courtier de traiter le temps comme une dépendance et de contrôler le comportement d'un service particulier en fonction de la valeur du temps à tout moment dans le passé, le présent ou le avenir.

### 1.4.0 Brokers d'entités
Les brokers d'entité sont les brokers fournissant des points d'intégration avec des ressources externes dont le système a besoin pour répondre aux exigences de l'entreprise.

Par exemple, les brokers d'entités sont des brokers qui s'intègrent au stockage, offrant des capacités pour stocker ou récupérer des enregistrements à partir d'une base de données.

Les brokers d'entités sont également comme les brokers de file d'attente, fournissant un point d'intégration pour pousser les messages vers une file d'attente pour que d'autres services les consomment et les traitent pour remplir leur logique métier.

Les brokers d'entités ne peuvent être appelés que par des services voisins de courtier, simplement parce qu'ils nécessitent un niveau de validation qui doit être effectué sur les données qu'ils reçoivent ou fournissent avant de continuer.

### 1.4.1 Brokers de support
Les brokers de support sont des brokers à usage général, ils fournissent une fonctionnalité aux services de support mais ils n'ont aucune caractéristique qui les rend différents d'un système ou d'un autre.

Un bon exemple de brokers de support est le `DateTimeBroker` - un courtier spécialement conçu pour éliminer la forte dépendance de la couche métier à l'heure de la date du système.

Les brokers en temps ne ciblent pas vraiment une entité spécifique, et ils sont presque les mêmes sur de nombreux systèmes.

Un autre exemple de brokers de support est le `LoggingBroker` - ils fournissent des données aux systèmes de journalisation et de surveillance pour permettre aux ingénieurs du système de visualiser le flux global de données à travers le système et d'être avertis en cas de problème.

Contrairement aux brokers d'entités - les brokers de support peuvent être appelés sur l'ensemble de la couche métier, ils peuvent être appelés sur les services de base, de traitement, d'orchestration, de coordination, de gestion ou d'agrégation. en effet, les brokers de journalisation sont nécessaires en tant que composant de support dans le système pour fournir toutes les fonctionnalités nécessaires aux services pour consigner leurs erreurs ou calculer une date ou toute autre fonctionnalité de support.

Vous pouvez trouver des exemples concrets de brokers dans le projet OtripleS [ici](https://github.com/hassanhabib/OtripleS/tree/master/OtripleS.Web.Api/Brokers).

## 1.5 Implémentation (Mise en oeuvre)
Voici une implémentation réelle d'un courtier de stockage complet pour toutes les opérations CRUD pour l'entité `Student` :

###### Pour IStorageBroker.cs:
```csharp
namespace OtripleS.Web.Api.Brokers.Storage
{
    public partial interface IStorageBroker
    {
    }
}

```

###### Pour StorageBroker.cs:
```csharp
using System;
using EFxceptions.Identity;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using OtripleS.Web.Api.Models.Users;

namespace OtripleS.Web.Api.Brokers.Storage
{
    public partial class StorageBroker : EFxceptionsContext, IStorageBroker
    {
        private readonly IConfiguration configuration;

        public StorageBroker(IConfiguration configuration)
        {
            this.configuration = configuration;
            this.Database.Migrate();
        }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            string connectionString = this.configuration.GetConnectionString("DefaultConnection");
            optionsBuilder.UseSqlServer(connectionString);
        }
    }
}
```

###### Pour IStorageBroker.Students.cs:
```csharp
using System;
using System.Linq;
using System.Threading.Tasks;
using OtripleS.Web.Api.Models.Students;

namespace OtripleS.Web.Api.Brokers.Storage
{
    public partial interface IStorageBroker
    {
        public ValueTask<Student> InsertStudentAsync(Student student);
        public IQueryable<Student> SelectAllStudents();
        public ValueTask<Student> SelectStudentByIdAsync(Guid studentId);
        public ValueTask<Student> UpdateStudentAsync(Student student);
        public ValueTask<Student> DeleteStudentAsync(Student student);
    }
}
``` 

###### Pour StorageBroker.Students.cs:
```csharp
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using OtripleS.Web.Api.Models.Students;

namespace OtripleS.Web.Api.Brokers.Storage
{
    public partial class StorageBroker
    {
        public DbSet<Student> Students { get; set; }

        public async ValueTask<Student> InsertStudentAsync(Student student)
        {
            using var broker = new StorageBroker(this.configuration);

            EntityEntry<Student> studentEntityEntry =
                await broker.Students.AddAsync(entity: student);

            await broker.SaveChangesAsync();

            return studentEntityEntry.Entity;
        }

        public IQueryable<Student> SelectAllStudents()
        {
            using var broker = new StorageBroker(this.configuration);

            return broker.Students;
        }

        public async ValueTask<Student> SelectStudentByIdAsync(Guid studentId)
        {
            using var broker = new StorageBroker(this.configuration);

            broker.ChangeTracker.QueryTrackingBehavior =
                QueryTrackingBehavior.NoTracking;

            return await broker.Students.FindAsync(studentId);
        }

        public async ValueTask<Student> UpdateStudentAsync(Student student)
        {
            using var broker = new StorageBroker(this.configuration);

            EntityEntry<Student> studentEntityEntry =
                broker.Students.Update(entity: student);

            await broker.SaveChangesAsync();

            return studentEntityEntry.Entity;
        }

        public async ValueTask<Student> DeleteStudentAsync(Student student)
        {
            using var broker = new StorageBroker(this.configuration);

            EntityEntry<Student> studentEntityEntry =
                broker.Students.Remove(entity: student);
                
            await broker.SaveChangesAsync();

            return studentEntityEntry.Entity;
        }
    }
}
```

## 1.6 Résumé
Les brokers sont la première couche d'abstraction entre votre logique métier et le monde extérieur, mais ils ne sont pas la seule couche d'abstraction. simplement parce qu'il y aura encore peu de modèles natifs qui fuiront à travers vos brokers vers vos services voisins de courtier, ce qui est naturel pour éviter de faire des mappages en dehors du domaine de la logique, dans notre cas ici les services de base.

Par exemple, dans un courtier de stockage, quel que soit l'ORM que vous utilisez, certaines exceptions natives de votre ORM (EntityFramework par exemple) se produiront, telles que `DbUpdateException` ou `SqlException` - dans ce cas, nous avons besoin d'une autre couche d'abstraction pour jouer le rôle d'un mappeur entre ces exceptions et notre logique de base pour les convertir en modèles d'exception locaux.

Cette responsabilité est entre les mains des brokers-services voisins, je les appelle aussi services de fondation, ces services sont le dernier point d'abstraction avant votre logique de base, dans laquelle tout ne devient que modèles et contrats locaux.

## 1.7 FAQs
Au fil du temps, il y a eu des questions communes qui se sont posées par les ingénieurs avec qui j'ai eu l'occasion de travailler tout au long de ma carrière - puisque certaines de ces questions se sont répétées à plusieurs reprises, j'ai pensé qu'il pourrait être utile de les agréger toutes ici pour que tout le monde en apprenne d'autres sur les brokers.

#### 1.7.0 Le pattern du broker est-il le même que le pattern du repository ?
Pas exactement, au moins d'un point de vue opérationnel, les brokers semblent être plus génériques que les référentiels.

Les référentiels ciblent généralement des opérations de type stockage, principalement vers des bases de données. mais les brokers peuvent être un point d'intégration avec toute dépendance externe telle que les services de messagerie, les files d'attente, d'autres API, etc.

Un pattern plus similaire pour les brokers est le pattern d'unité de travail, il se concentre principalement sur l'opération globale sans avoir à lier la définition ou le nom à une opération particulière.

Tous ces modèles essaient en général d'atteindre le même objectif des principes SOLID, qui est la séparation des préoccupations, l'injection de dépendance et la responsabilité unique.

Mais parce que SOLID sont des principes et non des directives exactes, on s'attend à voir tous les différents types d'implémentations et de modèles pour atteindre ce principe.

#### 1.7.1 Pourquoi les brokers ne peuvent-ils pas implémenter un contrat pour les méthodes qui renvoient une interface au lieu d'un modèle concret ?
Ce serait une situation idéale, mais cela obligerait également les brokers à effectuer une conversion ou un mappage entre les modèles natifs renvoyés par les SDK ou les API de ressources externes et le modèle interne qui adhère au contrat local.

Faire cela au niveau du courtier nécessitera de pousser la logique métier dans ce domaine, ce qui est complètement en dehors de l'objectif de ce composant.

Les brokers ne subissent pas de tests unitaires car ils ne contiennent aucune logique métier. Ils peuvent faire partie d'un test d'acceptation ou d'intégration, mais certainement pas de tests unitaires - simplement parce qu'ils ne contiennent aucune logique métier. . Nous définissons le code de logique métier comme tout code séquentiel, sélectif ou d'itération prévu.

#### 1.7.2 Si les brokers étaient vraiment une couche d'abstraction de la logique métier, comment se fait-il que nous permettions aux exceptions externes de les traverser vers la couche de services ?
Les brokers ne sont que la *première* couche d'abstraction, mais pas la seule - les services voisins du courtier sont responsables de la conversion des exceptions natives provenant d'un courtier en un modèle d'exception plus local qui peut être géré et traité en interne dans la logique métier royaume.

Le code local pur complet commence à se produire sur les couches de traitement, d'orchestration, de coordination et d'agrégation où toutes les exceptions, tous les modèles renvoyés et toutes les opérations sont localisés dans le système.

#### 1.7.3 Pourquoi utilisons-nous des classes partielles pour les brokers qui gèrent plusieurs entités?
Étant donné que les brokers doivent posséder leurs propres configurations, il était plus logique de procéder à une partialisation lorsque cela était possible pour éviter de reconfigurer chaque courtier de stockage pour chaque entité.

Il s'agit d'une fonctionnalité de C# spécifiquement en tant que langage, mais il devrait être possible de l'implémenter par héritage dans d'autres langages de programmation.

#### 1.7.4 Les brokers sont-ils les mêmes que les providers (Provider Pattern) ?
Non. Les fournisseurs brouillent la frontière entre les services (logique métier) et les brokers (couche d'intégration) - les brokers ciblent des composants particuliers du système qui sont jetables. Les fournisseurs semblent inclure plus que cela.


[*] [Implémentation de composants abstraits (brokers)](https://www.youtube.com/watch?v=6NlgSskQXSo)

[*] [Implémentation de composants abstraits (Partie 2)](https://www.youtube.com/watch?v=d1cqEKMBmno)

[*] [Génération de migrations de modèles avec Entity Framework](https://www.youtube.com/watch?v=6sD5zz9BuOk)
