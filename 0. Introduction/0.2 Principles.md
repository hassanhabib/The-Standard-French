# 0.2 Principes
Dans ce chapitre, nous allons explorer les principes de la Norme. Ces principes s'appliquent à tous les composants d'un système conforme à la Norme. Que ces composants soient des courtiers, des services ou des exposants.+<

## 0.2.0 People-First
L'idée principale de ce principe est de construire et de concevoir des systèmes conformes aux normes en pensant aux personnes. Pas seulement les personnes qui vont utiliser le système, mais aussi celles qui vont le maintenir et le faire évoluer.

Pour qu'un système suive le principe du people-first, il doit privilégier la simplicité à la complexité. La simplicité mène à la réécriture. Elle conduit également à concevoir des systèmes monolithiques qui sont construits avec un état d'esprit modulable pour permettre une véritable fractabilité dans le modèle global du système.

Le standard applique également les principes de mesure des concepts d'ingénierie avancés par rapport à la compréhension des ingénieurs ordinaires. Les nouveaux ingénieurs de l'industrie sont les leaders de demain. S'ils n'adhèrent pas à un système, ils finiront par l'abandonner et le réécrire encore et encore.

### 0.2.0.0 Simplicité
Les codes rédigés conformément au standard doivent être simples. Il existe des mesures pour garantir cette simplicité, ces mesures sont les suivantes :

#### 0.2.0.0.0 Héritage excessif
Tout logiciel écrit conformément au standard ne doit pas avoir plus d'un niveau d'héritage. Plus d'un niveau d'héritage sera considéré comme excessif et interdit. Sauf dans les cas de versioning pour la mise à l'échelle verticale des flows. L'héritage excessif s'est avéré au fil des années être une source de confusion et de difficulté en termes de lisibilité et de maintenabilité.

#### 0.2.0.0.1 Enchevêtrement

##### 0.2.0.0.1.0 Enchevêtrement horizontal
Construire des composants `communs` dans chaque système avec la promesse de simplifier le processus de développement est une autre pratique interdite dans les systèmes conformes au standard. Cette pratique se manifeste dans des composants portant des noms tels que `Utils`, `Commons` ou `Helpers`. Ces terminologies et ce qu'elles impliquent en termes de fausses simplifications promises ne sont pas autorisées. Tout système construit selon le standard devrait être composé de courtiers, de services ou d'exposants, ni plus ni moins.

Un autre exemple d'enchevêtrements horizontaux sont les modèles partagés sur plusieurs flux indépendants - partageant des exceptions, des règles de validation ou toute autre forme d'enchevêtrement sur plusieurs flux.

<br />
    <div align=center>
        <img src="https://user-images.githubusercontent.com/16063715/186167100-e2b5a8e3-7d6b-4969-b486-7c606554336c.png" />
    </div>
<br />

##### 0.2.0.0.1.1 Enchevêtrement vertical
Ce principe s'applique également aux scénarios où des composants de base sont utilisés. À moins que ces composants de base ne soient natifs ou externes, ils ne seront pas autorisés dans un système conforme au standard. Les composants de base locaux créent un niveau d'enchevêtrement vertical qui nuit à la maintenabilité et à la lisibilité du code. Les enchevêtrements verticaux sont tout aussi nocifs que les composants `communs` qui créent des points de défaillance uniques sur n'importe quel système.

Les enchevêtrements (verticaux ou horizontaux) empêchent également les ingénieurs de tout système (en particulier les nouveaux arrivants) de comprendre pleinement la profondeur du système et de posséder pleinement ses fonctionnalités. Ils empêchent également les ingénieurs d'avoir la possibilité de créer des flux de bout en bout lorsque la moitié de la fonctionnalité est vraisemblablement composable dans un souci d'accélération du développement et de simplicité.

<br />
    <div align=center>
        <img src="https://user-images.githubusercontent.com/16063715/186167157-45cf148d-c47f-407a-b951-fdbb7d1c0af6.png" />
    </div>
<br />

#### 0.2.0.0.2 Composants autonomes
Ce principe favorise la duplication plutôt que la simplification présumée via l'enchevêtrement de code. Chaque composant de chaque système doit être autonome. Chaque composant implémente ses propres validations, outils et utilitaires dans l'une de ses dimensions sans dépendance matérielle à l'égard d'autres composants externes, sauf par injection de dépendance.

Les composants autonomes offriront à chaque ingénieur de chaque équipe la possibilité de posséder pleinement toutes les dépendances et tous les outils dont leur composant peut avoir besoin pour remplir son objectif. Cela peut entraîner un peu de duplication dans une partie du code dans le but d'offrir une opportunité égale à chaque développeur d'apprendre pleinement comment créer et faire évoluer un composant.

##### 0.2.0.0.2.0 Pas de magie
Les composants autonomes placent toutes leurs routines devant l'ingénieur. Pas de routines cachées, de bibliothèques partagées ou d'extensions magiques qui nécessitent de rechercher des références une fois qu'une scission inévitable du grand monolithe commence à se produire.

Nous traiterons les objets comme ils sont dans la nature. composants multidimensionnels qui s'auto-conteneurisent comme des atomes dans la nature. Ces composants effectuent leurs propres validations, gestion des exceptions, traçage, sécurité, localisation et tout le reste entre les deux.

<br />
	<div align=center>
		<img src="https://user-images.githubusercontent.com/16063715/186167235-a32d57e5-6cd7-406a-a177-cd3acd5fde7e.png" />
	</div>
<br />

Les composants construits selon le standard adhèrent strictement à l'idée de _ce que vous voyez est ce que vous obtenez_ (Anglais:  _What You See Is What You Get_ ou WYSIWYG) - tout ce qui concerne les composants sera sur le composant lui-même.

## 0.2.1 Réinscriptibilité
Chaque système doit être développé en gardant à l'esprit le principe de réinscriptibilité. Le principe dicte que nos hypothèses dans les systèmes que nous développons ont le potentiel élevé d'être réexaminées et probablement reconsidérées. Chaque système doit être facilement réinscriptible en tant que mesure d'adhésion à des exigences commerciales en constante évolution et en constante évolution.

Le code réinscriptible est un code facile à comprendre, à modifier et à réécrire entièrement. Le code réinscriptible est extrêmement modulaire et autonome, il encourage les ingénieurs au faire évoluer avec le moins d'efforts et de risques possibles.

Le code réinscriptible ne joue pas de tours au lecteur. Il n'y a pas de dépendances cachées, de routines injectées au moment de l'exécution ni de prérequis inconnus. Il devrait être plug-n-play - fork, cloner, construire et exécuter tous ses tests avec succès sans aucun problème.

## 0.2.2 Mono-Micro
Construire des systèmes monolithiques avec un état d'esprit modulaire. Chaque flux doit être construit de manière totalement indépendante des autres flux. Par exemple, nous pouvons construire un système monolithique avec un état d'esprit microservice. Ce qui signifie que tout flux peut être extrait du système et transformé en son propre microservice ou lambda avec le moins d'effort possible.

Ce principe va de pair avec le concept de composants autonomes à un niveau supérieur où les flux sont également autonomes vis-à-vis de leur flux voisin et de leur système d'hébergement.

## 0.2.3 Niveau 0
Le code doit être compréhensible par une personne débutante dans le métier d'ingénieur. Notre base de code continue de vivre uniquement en fonction de sa facilité de compréhension par la grande majorité des ingénieurs de l'industrie. La grande majorité des ingénieurs de notre industrie seront toujours ceux qui sont nouveaux dans le métier.

Les ingénieurs de niveau 0 sont notre mesure du succès. Leur capacité à comprendre notre code est notre garantie que ce même code continuera à vivre et à évoluer avec la prochaine génération d'ingénieurs.

Ce principe oblige également chaque ingénieur de l'industrie à contre-interroger son code et à s'associer à des juniors sur le terrain pour voir s'ils respectent ce principe.

## 0.2.4 Open Code
Le open code en tant que principe dicte que tout ce qui est écrit selon le standard doit être accessible au public. Le développement d'outils internes qui ne sont pas accessibles nuira inévitablement à l'expérience d'ingénierie de ceux qui essaient de faire évoluer ces mêmes outils. Cela s'applique aux pratiques d'artefacts internes, aux bibliothèques à l'essai et à toute autre forme de développement de module qui ne permet pas à tous les ingénieurs du monde entier d'apprendre et de faire évoluer un système donné.

Le principe reconnaît également que dans des circonstances extrêmes, telles que lorsque la sécurité ou la sécurité sont menacées ou sous une obligation contractuelle, on ne peut pas mettre le code, les outils, les plates-formes et les modèles à la disposition du public. Cependant, rendre la source exclusive uniquement pour un gain personnel ou organisationnel n'est pas autorisé par The Standard.

## 0.2.5 Mode avion (Cloud-Foreign)
Le standard applique l'idée du mode avion. Où les ingénieurs peuvent mettre en place toute leur infrastructure sur leur machine locale sans avoir besoin ou avoir aucune forme de connexion réseau. Ce principe va fortement à l'encontre de principes tels que les applications Cloud-Native où un système donné ne peut pas fonctionner sans infrastructure cloud.

Le standard encourage également ses adaptateurs à développer les outils appropriés pour combler le fossé entre les composants d'infrastructure cloud et les composants locaux tels que les files d'attente, les hubs d'événements et tout autre outil pour le rendre facilement testable et modifiable.

## 0.2.6 Pas de Toasters
Le standard doit être enseignée d'homme à homme et non de machine à homme. Il ne devrait pas y avoir de stylecops ou d'analyseurs mis en œuvre pour forcer les gens à suivre le standard. Il doit être animé par la passion dans le cœur et la conviction dans l'esprit. La Norme doit être enseignée de personne à personne. Il vise à favoriser une culture d'ingénierie de discussions ouvertes, de conviction et de compréhension.

## 0.2.7 Passer en avant
Le standard doit être enseignée sans frais. Comme il vous est arrivé sans frais. Il devrait être transmis au prochain ingénieur également sans frais. Quel que soit leur statut financier, social ou éducatif. La Norme est la connaissance pure donnée par l'altruiste à l'altruiste. Il n'y aura pas d'en tirer profit, et ce ne sera pas non plus une raison pour que quelqu'un déprécie les autres ou les fasse se sentir moins. Enseigner le standard à des fins lucratives viole le standard et refuse à son bénéficiaire toute autre directive de l'auteur.