# 0.2 Principes
Dans ce chapitre, nous allons explorer les principes de la Norme. Ces principes s'appliquent &agrave; tous les composants d'un syst&egrave;me conforme &agrave; la Norme. Que ces composants soient des courtiers, des services ou des exposants.+<

## 0.2.0 People-First
L'id&eacute;e principale de ce principe est de construire et de concevoir des syst&egrave;mes conformes aux normes en pensant aux personnes. Pas seulement les personnes qui vont utiliser le syst&egrave;me, mais aussi celles qui vont le maintenir et le faire &eacute;voluer.

Pour qu'un syst&egrave;me suive le principe du people-first, il doit privil&eacute;gier la simplicit&eacute; &agrave; la complexit&eacute;. La simplicit&eacute; m&egrave;ne &agrave; la r&eacute;&eacute;criture. Elle conduit &eacute;galement &agrave; concevoir des syst&egrave;mes monolithiques qui sont construits avec un &eacute;tat d'esprit modulable pour permettre une v&eacute;ritable fractabilit&eacute; dans le mod&egrave;le global du syst&egrave;me.

Le standard applique &eacute;galement les principes de mesure des concepts d'ing&eacute;nierie avanc&eacute;s par rapport &agrave; la compr&eacute;hension des ing&eacute;nieurs ordinaires. Les nouveaux ing&eacute;nieurs de l'industrie sont les leaders de demain. S'ils n'adh&egrave;rent pas &agrave; un syst&egrave;me, ils finiront par l'abandonner et le r&eacute;&eacute;crire encore et encore.

### 0.2.0.0 Simplicit&eacute;
Les codes r&eacute;dig&eacute;s conform&eacute;ment au standard doivent &ecirc;tre simples. Il existe des mesures pour garantir cette simplicit&eacute;, ces mesures sont les suivantes :

#### 0.2.0.0.0 H&eacute;ritage excessif
Tout logiciel &eacute;crit conform&eacute;ment au standard ne doit pas avoir plus d'un niveau d'h&eacute;ritage. Plus d'un niveau d'h&eacute;ritage sera consid&eacute;r&eacute; comme excessif et interdit. Sauf dans les cas de versioning pour la mise &agrave; l'&eacute;chelle verticale des flows. L'h&eacute;ritage excessif s'est av&eacute;r&eacute; au fil des ann&eacute;es &ecirc;tre une source de confusion et de difficult&eacute; en termes de lisibilit&eacute; et de maintenabilit&eacute;.

#### 0.2.0.0.1 Enchev&ecirc;trement

##### 0.2.0.0.1.0 Enchev&ecirc;trement horizontal
Construire des composants `communs` dans chaque syst&egrave;me avec la promesse de simplifier le processus de d&eacute;veloppement est une autre pratique interdite dans les syst&egrave;mes conformes au standard. Cette pratique se manifeste dans des composants portant des noms tels que `Utils`, `Commons` ou `Helpers`. Ces terminologies et ce qu'elles impliquent en termes de fausses simplifications promises ne sont pas autoris&eacute;es. Tout syst&egrave;me construit selon le standard devrait &ecirc;tre compos&eacute; de courtiers, de services ou d'exposants, ni plus ni moins.

Un autre exemple d'enchev&ecirc;trements horizontaux sont les mod&egrave;les partag&eacute;s sur plusieurs flux ind&eacute;pendants - partageant des exceptions, des r&egrave;gles de validation ou toute autre forme d'enchev&ecirc;trement sur plusieurs flux.

<br />
    <div align=center>
        <img src="https://user-images.githubusercontent.com/16063715/186167100-e2b5a8e3-7d6b-4969-b486-7c606554336c.png" />
    </div>
<br />

##### 0.2.0.0.1.1 Enchev&ecirc;trement vertical
Ce principe s'applique &eacute;galement aux sc&eacute;narios où des composants de base sont utilis&eacute;s. &Agrave; moins que ces composants de base ne soient natifs ou externes, ils ne seront pas autoris&eacute;s dans un syst&egrave;me conforme au standard. Les composants de base locaux cr&eacute;ent un niveau d'enchev&ecirc;trement vertical qui nuit &agrave; la maintenabilit&eacute; et &agrave; la lisibilit&eacute; du code. Les enchev&ecirc;trements verticaux sont tout aussi nocifs que les composants `communs` qui cr&eacute;ent des points de d&eacute;faillance uniques sur n'importe quel syst&egrave;me.

Les enchev&ecirc;trements (verticaux ou horizontaux) emp&ecirc;chent &eacute;galement les ing&eacute;nieurs de tout syst&egrave;me (en particulier les nouveaux arrivants) de comprendre pleinement la profondeur du syst&egrave;me et de poss&eacute;der pleinement ses fonctionnalit&eacute;s. Ils emp&ecirc;chent &eacute;galement les ing&eacute;nieurs d'avoir la possibilit&eacute; de cr&eacute;er des flux de bout en bout lorsque la moiti&eacute; de la fonctionnalit&eacute; est vraisemblablement composable dans un souci d'acc&eacute;l&eacute;ration du d&eacute;veloppement et de simplicit&eacute;.

<br />
    <div align=center>
        <img src="https://user-images.githubusercontent.com/16063715/186167157-45cf148d-c47f-407a-b951-fdbb7d1c0af6.png" />
    </div>
<br />

#### 0.2.0.0.2 Composants autonomes
Ce principe favorise la duplication plut&ocirc;t que la simplification pr&eacute;sum&eacute;e via l'enchev&ecirc;trement de code. Chaque composant de chaque syst&egrave;me doit &ecirc;tre autonome. Chaque composant impl&eacute;mente ses propres validations, outils et utilitaires dans l'une de ses dimensions sans d&eacute;pendance mat&eacute;rielle &agrave; l'&eacute;gard d'autres composants externes, sauf par injection de d&eacute;pendance.

Les composants autonomes offriront &agrave; chaque ing&eacute;nieur de chaque &eacute;quipe la possibilit&eacute; de poss&eacute;der pleinement toutes les d&eacute;pendances et tous les outils dont leur composant peut avoir besoin pour remplir son objectif. Cela peut entraîner un peu de duplication dans une partie du code dans le but d'offrir une opportunit&eacute; &eacute;gale &agrave; chaque d&eacute;veloppeur d'apprendre pleinement comment cr&eacute;er et faire &eacute;voluer un composant.

##### 0.2.0.0.2.0 Pas de magie
Les composants autonomes placent toutes leurs routines devant l'ing&eacute;nieur. Pas de routines cach&eacute;es, de biblioth&egrave;ques partag&eacute;es ou d'extensions magiques qui n&eacute;cessitent de rechercher des r&eacute;f&eacute;rences une fois qu'une scission in&eacute;vitable du grand monolithe commence &agrave; se produire.

Nous traiterons les objets comme ils sont dans la nature. composants multidimensionnels qui s'auto-conteneurisent comme des atomes dans la nature. Ces composants effectuent leurs propres validations, gestion des exceptions, tra&ccedil;age, s&eacute;curit&eacute;, localisation et tout le reste entre les deux.

<br />
	<div align=center>
		<img src="https://user-images.githubusercontent.com/16063715/186167235-a32d57e5-6cd7-406a-a177-cd3acd5fde7e.png" />
	</div>
<br />

Les composants construits selon le standard adh&egrave;rent strictement &agrave; l'id&eacute;e de _ce que vous voyez est ce que vous obtenez_ (Anglais:  _What You See Is What You Get_ ou WYSIWYG) - tout ce qui concerne les composants sera sur le composant lui-m&ecirc;me.

## 0.2.1 R&eacute;inscriptibilit&eacute;
Chaque syst&egrave;me doit &ecirc;tre d&eacute;velopp&eacute; en gardant &agrave; l'esprit le principe de r&eacute;inscriptibilit&eacute;. Le principe dicte que nos hypoth&egrave;ses dans les syst&egrave;mes que nous d&eacute;veloppons ont le potentiel &eacute;lev&eacute; d'&ecirc;tre r&eacute;examin&eacute;es et probablement reconsid&eacute;r&eacute;es. Chaque syst&egrave;me doit &ecirc;tre facilement r&eacute;inscriptible en tant que mesure d'adh&eacute;sion &agrave; des exigences commerciales en constante &eacute;volution et en constante &eacute;volution.

Le code r&eacute;inscriptible est un code facile &agrave; comprendre, &agrave; modifier et &agrave; r&eacute;&eacute;crire enti&egrave;rement. Le code r&eacute;inscriptible est extr&ecirc;mement modulaire et autonome, il encourage les ing&eacute;nieurs au faire &eacute;voluer avec le moins d'efforts et de risques possibles.

Le code r&eacute;inscriptible ne joue pas de tours au lecteur. Il n'y a pas de d&eacute;pendances cach&eacute;es, de routines inject&eacute;es au moment de l'ex&eacute;cution ni de pr&eacute;requis inconnus. Il devrait &ecirc;tre plug-n-play - fork, cloner, construire et ex&eacute;cuter tous ses tests avec succ&egrave;s sans aucun probl&egrave;me.

## 0.2.2 Mono-Micro
Construire des syst&egrave;mes monolithiques avec un &eacute;tat d'esprit modulaire. Chaque flux doit &ecirc;tre construit de mani&egrave;re totalement ind&eacute;pendante des autres flux. Par exemple, nous pouvons construire un syst&egrave;me monolithique avec un &eacute;tat d'esprit microservice. Ce qui signifie que tout flux peut &ecirc;tre extrait du syst&egrave;me et transform&eacute; en son propre microservice ou lambda avec le moins d'effort possible.

Ce principe va de pair avec le concept de composants autonomes &agrave; un niveau sup&eacute;rieur où les flux sont &eacute;galement autonomes vis-&agrave;-vis de leur flux voisin et de leur syst&egrave;me d'h&eacute;bergement.

## 0.2.3 Niveau 0
Le code doit &ecirc;tre compr&eacute;hensible par une personne d&eacute;butante dans le m&eacute;tier d'ing&eacute;nieur. Notre base de code continue de vivre uniquement en fonction de sa facilit&eacute; de compr&eacute;hension par la grande majorit&eacute; des ing&eacute;nieurs de l'industrie. La grande majorit&eacute; des ing&eacute;nieurs de notre industrie seront toujours ceux qui sont nouveaux dans le m&eacute;tier.

Les ing&eacute;nieurs de niveau 0 sont notre mesure du succ&egrave;s. Leur capacit&eacute; &agrave; comprendre notre code est notre garantie que ce m&ecirc;me code continuera &agrave; vivre et &agrave; &eacute;voluer avec la prochaine g&eacute;n&eacute;ration d'ing&eacute;nieurs.

Ce principe oblige &eacute;galement chaque ing&eacute;nieur de l'industrie &agrave; contre-interroger son code et &agrave; s'associer &agrave; des juniors sur le terrain pour voir s'ils respectent ce principe.

## 0.2.4 Open Code
Le open code en tant que principe dicte que tout ce qui est &eacute;crit selon le standard doit &ecirc;tre accessible au public. Le d&eacute;veloppement d'outils internes qui ne sont pas accessibles nuira in&eacute;vitablement &agrave; l'exp&eacute;rience d'ing&eacute;nierie de ceux qui essaient de faire &eacute;voluer ces m&ecirc;mes outils. Cela s'applique aux pratiques d'artefacts internes, aux biblioth&egrave;ques &agrave; l'essai et &agrave; toute autre forme de d&eacute;veloppement de module qui ne permet pas &agrave; tous les ing&eacute;nieurs du monde entier d'apprendre et de faire &eacute;voluer un syst&egrave;me donn&eacute;.

Le principe reconnaît &eacute;galement que dans des circonstances extr&ecirc;mes, telles que lorsque la s&eacute;curit&eacute; ou la s&eacute;curit&eacute; sont menac&eacute;es ou sous une obligation contractuelle, on ne peut pas mettre le code, les outils, les plates-formes et les mod&egrave;les &agrave; la disposition du public. Cependant, rendre la source exclusive uniquement pour un gain personnel ou organisationnel n'est pas autoris&eacute; par The Standard.

## 0.2.5 Mode avion (Cloud-Foreign)
Le standard applique l'id&eacute;e du mode avion. Où les ing&eacute;nieurs peuvent mettre en place toute leur infrastructure sur leur machine locale sans avoir besoin ou avoir aucune forme de connexion r&eacute;seau. Ce principe va fortement &agrave; l'encontre de principes tels que les applications Cloud-Native où un syst&egrave;me donn&eacute; ne peut pas fonctionner sans infrastructure cloud.

Le standard encourage &eacute;galement ses adaptateurs &agrave; d&eacute;velopper les outils appropri&eacute;s pour combler le foss&eacute; entre les composants d'infrastructure cloud et les composants locaux tels que les files d'attente, les hubs d'&eacute;v&eacute;nements et tout autre outil pour le rendre facilement testable et modifiable.

## 0.2.6 Pas de Toasters
Le standard doit &ecirc;tre enseign&eacute;e d'homme &agrave; homme et non de machine &agrave; homme. Il ne devrait pas y avoir de stylecops ou d'analyseurs mis en oeuvre pour forcer les gens &agrave; suivre le standard. Il doit &ecirc;tre anim&eacute; par la passion dans le coeur et la conviction dans l'esprit. La Norme doit &ecirc;tre enseign&eacute;e de personne &agrave; personne. Il vise &agrave; favoriser une culture d'ing&eacute;nierie de discussions ouvertes, de conviction et de compr&eacute;hension.

## 0.2.7 Passer en avant
Le standard doit &ecirc;tre enseign&eacute;e sans frais. Comme il vous est arriv&eacute; sans frais. Il devrait &ecirc;tre transmis au prochain ing&eacute;nieur &eacute;galement sans frais. Quel que soit leur statut financier, social ou &eacute;ducatif. La Norme est la connaissance pure donn&eacute;e par l'altruiste &agrave; l'altruiste. Il n'y aura pas d'en tirer profit, et ce ne sera pas non plus une raison pour que quelqu'un d&eacute;pr&eacute;cie les autres ou les fasse se sentir moins. Enseigner le standard &agrave; des fins lucratives viole le standard et refuse &agrave; son b&eacute;n&eacute;ficiaire toute autre directive de l'auteur.