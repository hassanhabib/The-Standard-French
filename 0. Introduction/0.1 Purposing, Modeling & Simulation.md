# 0.1 Fixer des objectifs, modéliser et simuler

## 0.1.0 Introduction

Le standard défines le processus d'ingénierie logicielle en trois catégories principales. La conception, la modélisation et la simulation. Chacun de ces aspects joue un rôle crucial pour guider les efforts de l'ingénierie vers la production d'une solution réussie et la satisfaction d'un objectif particulier.

L'ordre dans lequel ces aspects sont suivis est également intentionnel. Il doit exister un objectif pour façonner le processus de modélisation. Et on ne peut pas simuler des interactions sans modèle. Mais si cet ordre au début du processus d'ingénierie est crucial, il est important de comprendre que le processus lui-même est sélectivement itératif. Un changement dans l'objectif peut se reflecter par un changement dans la simulation mais pas nécessairement dans la modélisation. Un changement dans les modèles ne nécessite pas nécessairement un changement dans l'objectif ou la simulation.

<br />
	<div align=center>
		<img width="50%" src="https://user-images.githubusercontent.com/16063715/186153128-56c7cb11-0316-4a9c-bce1-264a45da6809.png" />
	</div>
<br />

## 0.1.1 Fixer des objectifs

Le processus d'élaboration du but est notre capacité à findir pourquoi nous avons besoin d'une solution. Par exemple, si nous avons un problème pour savoir combien d'articles sont sur l'étagère dans une certaine épicerie. Nous estimons que le processus manuel de comptage est inefficient et qu'un système doit être mis en place pour s'assurer que nous avons le bon nombre d'articles.

Purposing consiste donc à findre une raison d'entreprendre une action. Le raisonnement s'appuie fortement sur l'observabilité. Notre capacité à observer les problèmes et ensuite à être capable d'articuler le problème pour mieux concevoir une solution qui répond au problème donné.

Nous avons donc l'observation, l'articulation du raisonnement (le problème) et l'intention de trouver une solution. Tous ces aspects constituent la partie Purposing du logiciel d'ingénierie.

### 0.1.1.0 Observation

Nous vivons dans un monde rempli d'éléments observables. Notre inspiration est déclenchée par notre ambition de réaliser davantage. Nos rêves révèlent des blocages sur notre chemin que nous devons résoudre pour poursuivre notre voyage et fulfillent nos rêves. Depuis le moment où un jeune étudiant utilise une calculatrice pour résoudre une équation complexe jusqu'au moment où ce même étudiant devient un astronaute, calculant la trajectoire des satellites en orbite autour de notre planète.

L'observation est notre capacité à détecter un problème qui empêche la réalisation d'un objectif. Les problèmes peuvent être aussi simples que de trouver le bon nombre d'articles sur une étagère d'épicerie. Il peut aussi s'agir de comprendre pourquoi nous ne pouvons pas capturer des images de planètes situées à des millions d'années-lumière de nous. Ce sont tous des problèmes que les ingénieurs qualifieraient d'observables.

Plus l'objectif est grand, plus le problème sera complexe. Mais ces petits objectifs nous permettent d'entraîner nos esprits à s'attaquer à des problèmes plus importants. Étape par étape, un problème à la fois.

### 0.1.1.1 Articulation

Décrire l'observable est un art en soi. Car décrire correctement un problème est la moitié du chemin vers sa solution. Plus l'articulation du problème est claire, plus le problème a de chances d'être compris par d'autres personnes qui nous aident à résoudre ces mêmes problèmes.

L'articulation n'est pas toujours avec les mots. Elle l'est aussi avec des figures et des formes. Ce n'est pas un hasard si certaines des cultures anciennes les plus avancées ont utilisé des figures et des formes pour décrire leur époque et leur histoire. Les figures sont un langage universel, compris et interprété par toute personne pouvant s'y référer beaucoup plus rapidement que l'apprentissage d'une langue parlée. En fait, une figure ou une forme pourrait être le moyen le plus optimal d'illustrer une idée, car ses images valent des milliers de mots.

L'articulation requiert la passion de résoudre le problème. Qu'elle soit écrite, dite ou illustrée. Un esprit passionné doit transmettre le message caché de la criticité du problème à résoudre. L'articulation d'un problème est une grande partie de la façon dont on peut vendre sa solution. Notre capacité à transmettre une idée à d'autres ingénieurs, puis à ceux qui investiront et utiliseront cette solution, est l'un des aspects les plus importants des logiciels d'ingénierie.

### 0.1.1.2 Solutionner

Une partie de l'objectif est la façon de le fulfilmer. Dans l'industrie de l'ingénierie, remplir les objectifs ne peut pas se faire par n'importe quel moyen. Un aspect énorme de la raison pour laquelle tant de logiciels massifs échouent dans le monde est que l'aspect de la solution a été négligé comme une partie triviale de l'objectif. Vous avez peut-être entendu parler de ceux qui, pressés par le temps, ont décidé de faire des économies pour atteindre leur objectif. Dans notre norme, il s'agit d'une violation. Une solution ne doit pas seulement répondre à un objectif, mais elle doit être un objectif en soi. Ceci en termes d'optimisation, de lisibilité, de configurabilité et de longévité.

L'élaboration de solutions dans le cadre de l'objectif est l'artisanat du logiciel.

## 0.1.2 Modélisation

La modélisation est le deuxième aspect le plus important du génie logiciel. C'est notre capacité à extraire des modèles des acteurs d'un problème quelconque. Que ces acteurs soient des êtres vivants, des objets ou autres. Par exemple, dans un problème où nous essayons de compter les articles sur une étagère d'épicerie, un modèle serait pour ces articles. En extrayant uniquement les attributs pertinents pour le problème que nous essayons de résoudre, et en rejetant tout le reste.

Un exemple plus simple serait de détecter les articles périssables dans une épicerie. Le seul attribut qui nous intéresse ici est la date d'expiration de l'article. Tout le reste, y compris l'étiquette, la couleur, le poids ou tout autre détail, n'entre pas dans le cadre du processus de modélisation et de la solution.
 
La modélisation ne peut donc pas exister sans un objectif. Comme le but défines la portée ou le cadre dans lequel la modélisation doit se produire. La modélisation sans but laisse la porte ouverte à l'attraction d'un nombre infini d'attributs que chaque élément de l'univers observable peut avoir.

La relation entre les attributs de l'objet et de la modélisation est proportionnelle. Plus l'objectif est complexe, plus le processus de modélisation nécessitera d'attributs du monde réel à reproduire dans un prototype.

Nous exprimons nos modèles dans les langages de programmation comme une classe (`class`). Le problème des articles périssables mentionné ci-dessus peut être représenté comme suit :

```csharp
public class Item
{
	public DateTimeOffset ExpirationDate {get; set;}
}
```

Le nom de la classe (`class`) représente le `type` général de l'élément. Étant donné que tous les éléments ont exactement le même attribut `ExpirationDate`, le nom doit rester aussi générique que possible.

Maintenant, imaginez si notre objectif devenait un peu plus complexe. Supposons que le nouveau problème est de pouvoir identifier les articles périssables les plus chers afin que le magasin puisse les vendre avant les articles les moins chers. Dans ce cas, notre modèle nécessiterait un nouvel attribut tel que `price` (prix) afin qu'un programme informatique ou une solution puisse déterminer lequel a le plus de valeur. Voici à quoi ressemblerait notre nouveau modèle :

```csharp
public class Item
{
	public double Price {get; set;}
	public DateTimeOffset ExpirationDate {get; set;}
}
```

### 0.1.2.0 Types de modèles
Les modèles régissent l'ensemble du processus de simulation d'un problème (et de sa solution). Les modèles eux-mêmes se divisent en trois catégories principales, les supports de données, les opérations et les configurations. Discutons de ces types dans les sections suivantes :

#### 0.1.2.0.0 Modèles de supports de données
Les modèles de support de données ont un objectif principal qui est de transporter des points de données à travers les systèmes. Les modèles de supports de données peuvent varier en fonction du type de données qu'ils transportent. Certains modèles de support de données porteront d'autres modèles pour représenter un système complexe. Certains autres représenteront simplement des références aux points de données d'origine qu'ils représentent.

Les modèles de supports de données de manière relationnelle peuvent être divisés en trois catégories différentes. Ces catégories permettent de mieux comprendre quels sont les domaines prioritaires en termes de développement, de conception et d'ingénierie. Par exemple, nous ne pouvons pas commencer à développer des modèles secondaires/de support si nous n'avons pas d'abord mis en place nos modèles principaux. Parlons de ces catégories en détails :

#### 0.1.2.0.0.0 Modèles primaires
Les modèles primaires sont les piliers de tout système. Un système donné ne peut avancer en termes de conception et d'ingénierie sans une définition claire et une matérialisation de ces modèles primaires. Par exemple, si nous construisons un système scolaire, des modèles tels que `Student` (étudiant), `Teacher` (enseignant) et `Course` (cours) sont considérés comme des modèles primaires.

Nous appelons ces modèles Primaires car ils se suffisent à eux-mêmes. Ils ne s'appuient pas physiquement sur un autre modèle pour exister. Ce qui signifie qu'un modèle primaire donné tel que `Student` peut toujours exister dans un système scolaire, qu'un enregistrement `Teacher` existe ou non. C'est ce qu'on appelle la dépendance physique. Les modèles principaux d'un schéma de stockage relationnel ne contiennent aucune clé étrangère ou référence à un autre modèle physique.

Les modèles primaires peuvent cependant s'appuyer conceptuellement ou logiquement sur d'autres modèles. Par exemple, un modèle `Student` a une relation logique avec un `Teacher`. Tout simplement parce qu'il ne peut jamais y avoir d'étudiant sans enseignat et vice versa. Un modèle `Student` a également une relation conceptuelle avec son hôte et les services d'hébergement voisins. Par exemple, il existe une relation conceptuelle entre un modèle `Student` et un modèle "Notification" en termes de flux métier. Conceptuellement, n'importe quel étudiant dans n'importe quelle école s'appuie sur les notifications pour assister à certains cours, effectuer certains devoirs ou tout autre événement.

#### 0.1.2.0.0.1 Modèles secondaires
Les modèles secondaires, quant à eux, dépendent fortement des modèles primaires. Dans un modèle de base de données relationnelle, les modèles secondaires ont généralement des clés étrangères qui font référence à un autre modèle dans le schéma global de la base de données. Mais même dans les systèmes de stockage non relationnels, les modèles secondaires peuvent être représentés comme des entités imbriquées dans une entité plus grande donnée ou avoir une référence libre à une autre entité.

Parlons de quelques exemples de modèles secondaires. un modèle `Commentaire` (commentaire) dans une plate-forme de médias sociaux ne peut exister sans un modèle `Post` (Publication). Vous ne pouvez tout simplement pas commenter quelque chose qui n'existe pas. Dans une base de données relationnelle, le modèle de commentaires ressemblerait à ceci :

<br />

<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155897099-5dd8aa3d-f6c2-4504-ba42-5e911c21a09a.png" />
</div>

<br />

Dans l'exemple ci-dessus, un modèle secondaire `Comment` a une clé étrangère `PostId` référençant la clé primaire `Id` dans un modèle `Post`. Dans un système non relationnel, les modèles secondaires peuvent facilement être identifiés comme des objets imbriqués dans une entité donnée. Voici un exemple :

```json
{
	"id": "some-id",
	"content": "some post",
	"comments": [
		{
			"id": "comment-id",
			"content": "some comment"
		}
	]
}
```

Les modèles secondaires en général peuvent avoir des relations logiques et conceptuelles avec d'autres modèles au sein de leurs systèmes hôtes, voisins ou externes. Cependant, leurs chances d'avoir ces relations conceptuelles sont bien moindres que les modèles primaires.

#### 0.1.2.0.0.2 Modèles relationnels
Les modèles relationnels sont des connecteurs entre deux modèles primaires. Leur principale responsabilité est de matérialiser une relation plusieurs-à-plusieurs entre deux entités. Par exemple, un étudiant (`Student`) peut avoir plusieurs enseignants et un enseignant `Teacher` peut avoir plusieurs étudiants. Dans ce cas un modèle intermédiaire.

Les modèles relationnels ne sont pas censés contenir de détails. Ils ne contiennent que des références à d'autres modèles et c'est leur clé primaire. Une clé composite qui agrège deux ou plusieurs clés étrangères en son sein. Prenons un exemple :

<br />

<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155897988-f865d0ef-9e22-421f-afe8-8d987bb67464.png" />
</div>

<br />

#### 0.1.2.0.0.3 Modèles hybrides
Il existe une situation où un modèle connecte plusieurs entités mais transporte également ses propres données. Je déconseille fortement de suivre cette voie pour maintenir un niveau de pureté dans la conception de votre système et contrôler la complexité de vos modèles. Cependant, cette approche est parfois une option nécessaire pour procéder à une certaine implémentation ou à un flux commercial. Dans ce cas, nous pouvons proposer un modèle hybride qui peut porter certains détails sur la relation entre deux entités indépendantes.

Voici un exemple de modèle hybride qui peut se produire dans la réalité. Dans un scénario de suppression réversible, un modèle hybride peut décrire le détachement entre deux entités dans une relation plusieurs à plusieurs. Supposons qu'un membre du groupe ne souhaite plus faire partie d'un certain groupe. Nous considérons leur appartenance au groupe comme désactivée (`Deactivated`) avec une raison jointe sans réellement supprimer complètement l'enregistrement. Voici à quoi cela ressemblerait :

<br />
<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155970437-3599c84c-b27a-471f-979a-17b624dd6b63.png" />
</div>
<br />

Dans un modèle de données non relationnel, l'intégrité du référencement peut devenir un peu plus lâche compte tenu de la nature linéaire de ce schéma. Les modèles hybrides combinent les deux modèles secondaires dans la manière dont ils référencent les modèles primaires, et ils mettent en oeuvre une nature relationnelle dans laquelle ils permettent à plusieurs entités de se relier les unes aux autres sans exclusivité.

#### 0.1.2.0.1 Modèles opérationnels
Les modèles opérationnels ciblent principalement l'aspect simulation de tout système logiciel. Pensez à toutes les opérations primitives, complexes et d'exposition qu'un scénario simple pourrait nécessiter pour qu'une simulation réussie soit mise en oeuvre. Supposons que nous essayons de résoudre un problème où nous pouvons simplifier les inscriptions des étudiants dans une école. Le processus d'inscription nécessitera une simulation pour ajouter ces informations sur les étudiants dans un système informatisé.

Les modèles opérationnels géreront l'exposition, le traitement et l'intégration de l'ensemble de ce processus, en offrant des services qui offrent des API/UI pour saisir, publier, ajouter et insérer/perserver les informations des étudiants dans certains systèmes scolaires.

Les modèles opérationnels peuvent être divisés en trois catégories principales, qui sont : l'intégration, le traitement et l'exposition. Le standard se concentre fortement sur les modèles opérationnels car ils représentent le coeur de tout système en termes de flux commerciaux. Les modèles opérationnels sont également là où la plupart des ressources de développement et de conception vont dans tout effort de développement logiciel.

Parlons des modèles opérationnels ici.

#### 0.1.2.0.1.0 Modèles d'intégration (Courtiers ou Brokers)
La principale responsabilité des modèles opérationnels d'intégration est de connecter tout système existant à des ressources externes. Ces ressources peuvent être localisées dans l'environnement de ce système comme la lecture de la date ou de l'heure actuelle ou à distance comme l'appel d'une API externe ou la persistance de données dans une base de données.

Nous appelons ces modèles d'intégration des Brokers. Ils jouent le rôle de liaison entre les modèles opérationnels de traitement et les systèmes externes. Voici un exemple :

```csharp
public partial class ApiBroker
{
	public async ValueTask<Student> PostStudentAsync(Student student) =>
		this.apiBroker.PostAsync<Student>(student, url);
}
```

Le modèle d'intégration ci-dessus offre la possibilité d'appeler une API externe, tout en extrayant les détails de configuration des modèles opérationnels de traitement.

Comme tout autre type de modèle opérationnel, ils ne contiennent pas de données, mais utilisent plutôt des membres de classe privés et des constantes pour partager des données internes entre ses méthodes publiques et privées. Le `ApiBroker` ici en tant que modèle représente une simulation d'intégration avec un système externe.

Nous discuterons en détail des courtiers dans les prochains chapitres pour faire la lumière sur les règles et les directives relatives au développement de courtiers avec des ressources ou des systèmes externes.

#### 0.1.2.0.1.1 Modèles de traitement/du processing (Services)
Les modèles de traitement (Ou du processing) sont les détenteurs de toutes les simulations métier. Des choses comme les inscriptions d'étudiants, la demande d'une nouvelle carte de bibliothèque ou simplement la récupération de certaines informations sur les étudiants en fonction de certains critères. Les modèles de traitement eux-mêmes peuvent être primitifs/fondamentaux, d'ordre supérieur/de traitement ou avancés/orchestrateurs.

Les modèles du processing en général s'appuient sur des modèles d'intégration, ou sont autonomes comme les services de traitement informatique ou s'appuient les uns sur les autres.

Voici un exemple de service fondamental/primitif simple :

```csharp
public partial class StudentService : IStudentService
{
	private readonly IStorageBroker storageBroker;
	...

	public async ValueTask<Student> AddStudentAsync(Student student) =>
		await this.storageBroker.InsertStudentAsync(student);
}
```

Un service d'ordre supérieur ferait/ressemblerait à ceci :

```csharp
public partial class StudentProcessingService : IStudentProcessingService
{
	private readonly IStudentService studentService;
	...

	public async ValueTask<Student> UpsertStudentAsync(Student student)
	{
		....

		Student maybeStudent = await this.studentService
			.RetrieveStudentByIdAsync(student.Id);
		
		return maybeStudent switch
		{
			null => await this.studentService.AddStudentAsync(student),
			_ => await this.studentService.ModifyStudentAsync(student)
		}
	}
}
```

Des services de type orchestration plus avancés combineraient plusieurs services de traitement ou de base comme suit :
```csharp
public partial class StudentOrchestrationService : IStudentOrchestrationService
{
	private readonly IStudentProcessingService studentProcessingService;
	private readonly IStudentLibraryCardProcessingService studentLibraryCardProcessingService;
	...

	public async ValueTask<Student> RegisterStudentAsync(Student student)
	{
		....
		Student upsertedStudent = await this.studentProcessingService
			.UpsertStudentAsync(student);

		...

		await this.studentLibraryProcessingService.AddStudentLibraryCardAsync(studentLibraryCard);
	}
}
```

En général, les modèles opérationnels ne concernent que la nature de la simulation ou du traitement de certains modèles de support de données, ils ne concernent pas la rétention de données, ni la conservation d'un statut. En général, les modèles opérationnels sont sans état dans le sens où ils ne conservent aucun des détails qui les ont parcourus, à part la délégation de la journalisation à des fins d'observabilité et de surveillance.

#### 0.1.2.0.1.2 Modèles d'exposition (Exposers)
Les modèles d'exposition gèrent l'IHM dans tous les scénarios où un humain et un système doivent interagir. Il peut s'agir de simples API RESTful, de SDK ou simplement d'une interface utilisateur comme dans les applications Web, mobiles ou de bureau, y compris les systèmes/terminaux basés sur la ligne de commande.

Les modèles opérationnels d'exposition sont comme les modèles d'intégration, ils permettent au monde extérieur d'interagir avec votre système. Ils se trouvent à l'autre bout de tout système et sont responsables de l'acheminement de chaque demande, communication ou appel vers les modèles opérationnels appropriés. Les modèles d'exposition ne communiquent jamais directement avec les modèles d'intégration, et ils n'ont aucune configuration en leur sein autre que leurs dépendances injectées via leurs constructeurs.

Les modèles d'exposition peuvent avoir leur propre langage en termes d'opérations, par exemple, un modèle d'intégration peut utiliser un langage tel que "InsertStudent", tandis qu'un modèle d'exposition pour un point de terminaison API utiliserait un langage tel que "PostStudent" pour exprimer la même opération dans un contexte d'exposition.

Voici un exemple de modèles d'exposition :

```csharp
public class StudentsController
{
	private readonly IStudentOrchestrationService studentOrchestrationService;

	[HttpGet]
	public async ValueTask<ActionResult<Student>> PostStudentAsync(Student student)
	{
		Student registeredStudent = await this.studentOrchestrationService
			.RegisterStudentAsync(student);

		return Ok(registeredStudent);
	}
}
```

Le modèle ci-dessus expose un point de terminaison API pour la communication RESTful afin d'offrir la possibilité d'inscrire les étudiants dans un système scolaire. Nous discuterons plus en détail des types de modèles d'exposition en fonction du contexte et du système dans lequel ils sont mis en oeuvre.

#### 0.1.2.0.2 Modèles de configuration
Le dernier type de modèles dans tout système sont les modèles de configuration. Ils peuvent représenter le point d'entrée dans n'importe quel système, ou enregistrer des dépendances pour n'importe quel système ou simplement jouer le rôle de middleware pour acheminer les URL vers leur fonction respective au sein d'un modèle d'exposition.

Les modèles de configuration se situent généralement au début du lancement d'un système, ou gèrent les communications entrantes et en cours ou gèrent simplement les opérations système sous-jacentes telles que la mise en cache de la mémoire, la gestion des threads, etc.

Dans une simple application d'API, vous pouvez voir des modèles qui ressemblent à ceci :

```csharp
public class Startup
{
	public void ConfigureServices(IServices services)
	{
		services.AddTransient<IStorageBroker, StorageBroker>();
		services.AddOAuth();
	}	
}
```

Comme vous pouvez le voir dans l'extrait de code ci-dessus, le modèle de configuration  `Startup` offre des capacités pour gérer l'enregistrement des contrats basé sur l'injection de dépendances dans leurs implémentations concrètes. Ils peuvent gérer l'ajout de sécurité ou la mise en place d'un pipeline middleware. Les modèles de configuration sont spécifiques à la technologie. Ils peuvent différer d'un framework Play en Scala à un Spring ou Flex en Python ou Java. Nous décrirons les règles de haut niveau selon le standard pour les modèles de configuration, mais nous n'approfondirons pas les détails de leur mise en oeuvre.

## 0.1.3 Simulation

L'aspect simulation du génie logiciel est notre capacité à ressembler aux interactions vers et depuis les modèles. Par exemple, dans l'exemple de l'épicerie, une simulation serait l'acte de *vendre* l'article. La vente de l'article nécessite plusieurs modifications de l'article en termes de déduction du nombre d'articles disponibles et de réorganisation des articles restants en fonction de l'article disponible le plus précieux.

Le processus de simulation peut être décrit comme illustrant les relations entre les modèles. elles sont programmées en tant que `fonctions`, `méthodes` ou `routines` et signifient toutes la même chose. Si nous avons un service logiciel responsable des ventes d'articles, un processus de simulation ressemblerait à ceci :

```csharp
public class SaleService
{
	public void Sell(Item item) => Items.Remove(item);
}
```

Dans l'exemple ci-dessus, nous avons un modèle appelé `SaleService` qui offre une fonctionnalité pour simuler le processus de vente dans le monde réel sur un modèle d'article. Et c'est ainsi que vous décrivez tout dans la programmation orientée objet. Tout est objet (issu d'un modèle) et ces objets interagissent entre eux (simulation).

Les objets qui interagissent en général peuvent être observés dans trois types différents. Un modèle effectuant une action sur un autre modèle. Par exemple, le `SaleService` exécute une action de `Sell` sur un modèle `Item`. C'est un modèle qui interagit avec un autre modèle. Dans le même exemple, une simulation pourrait être quelque chose qui arrive au modèle à partir d'un autre modèle tel que "l'élément" dans l'exemple susmentionné. Et le dernier type de simulation est un modèle interagissant avec lui-même. Des modèles qui s'auto-disposent une fois leur objectif atteint et dont ils ne sont plus nécessaires par exemple. Ils s'autodétruiront.

Le processus de simulation est le troisième et dernier aspect du génie logiciel. Ce que nous approfondirons lorsque nous parlerons des courtiers, des services et des exposants pour illustrer comment le processus de modélisation et de simulation se déroule dans le logiciel industriel.

## 0.1.4 Résumé

Si nous considérions la finalité comme le domaine ou le cadre dans lequel les modèles interagissent. Ensuite, l'illustration suivante devrait simplifier et rendre l'image un peu plus claire :

<br />
	<div align=center>
		<img width="50%" src="https://user-images.githubusercontent.com/16063715/186160196-fa50daf8-dbfc-47c3-8715-9628f8ff269a.png" />
	</div>
<br />

Il est important de comprendre qu'un logiciel informatique peut servir à plusieurs fins. Les logiciels informatiques peuvent interagir avec d'autres logiciels qui partagent des objectifs communs. Le but du logiciel devient le modèle et les intégrations deviennent les simulations dans cet aspect. Voici un exemple de 10 000 pieds :
<br />
	<div align=center>
		<img width="75%" src="https://user-images.githubusercontent.com/16063715/186160715-21da21d7-754d-452d-a101-d6c9617ad839.png" />
	</div>
<br />

La complexité de tout grand système peut être très facilement décomposée en problèmes plus petits si l'aspect d'objectif unique ou de responsabilité unique était appliqué pour chaque sous-système. C'est ce que les architectures logicielles modernes appelleraient la granularité et la modularisation. Ce dont nous discuterons brièvement tout au long de l'aspect architecture du standard.

[*] [Fixer des objectifs, modéliser et simuler (Partie 1) - En anglais](https://www.youtube.com/watch?v=Doul1gZKCuU)
