# 0.1 Fixer des objectifs, mod&eacute;liser et simuler

## 0.1.0 Introduction

Le standard d&eacute;fines le processus d'ing&eacute;nierie logicielle en trois cat&eacute;gories principales. La conception, la mod&eacute;lisation et la simulation. Chacun de ces aspects joue un r&ocirc;le crucial pour guider les efforts de l'ing&eacute;nierie vers la production d'une solution r&eacute;ussie et la satisfaction d'un objectif particulier.

L'ordre dans lequel ces aspects sont suivis est &eacute;galement intentionnel. Il doit exister un objectif pour fa&ccedil;onner le processus de mod&eacute;lisation. Et on ne peut pas simuler des interactions sans mod&egrave;le. Mais si cet ordre au d&eacute;but du processus d'ing&eacute;nierie est crucial, il est important de comprendre que le processus lui-m&ecirc;me est s&eacute;lectivement it&eacute;ratif. Un changement dans l'objectif peut se reflecter par un changement dans la simulation mais pas n&eacute;cessairement dans la mod&eacute;lisation. Un changement dans les mod&egrave;les ne n&eacute;cessite pas n&eacute;cessairement un changement dans l'objectif ou la simulation.

<br />
	<div align=center>
		<img width="50%" src="https://user-images.githubusercontent.com/16063715/186153128-56c7cb11-0316-4a9c-bce1-264a45da6809.png" />
	</div>
<br />

## 0.1.1 Fixer des objectifs

Le processus d'&eacute;laboration du but est notre capacit&eacute; &agrave; findir pourquoi nous avons besoin d'une solution. Par exemple, si nous avons un probl&egrave;me pour savoir combien d'articles sont sur l'&eacute;tag&egrave;re dans une certaine &eacute;picerie. Nous estimons que le processus manuel de comptage est inefficient et qu'un syst&egrave;me doit &ecirc;tre mis en place pour s'assurer que nous avons le bon nombre d'articles.

Purposing consiste donc &agrave; findre une raison d'entreprendre une action. Le raisonnement s'appuie fortement sur l'observabilit&eacute;. Notre capacit&eacute; &agrave; observer les probl&egrave;mes et ensuite &agrave; &ecirc;tre capable d'articuler le probl&egrave;me pour mieux concevoir une solution qui r&eacute;pond au probl&egrave;me donn&eacute;.

Nous avons donc l'observation, l'articulation du raisonnement (le probl&egrave;me) et l'intention de trouver une solution. Tous ces aspects constituent la partie Purposing du logiciel d'ing&eacute;nierie.

### 0.1.1.0 Observation

Nous vivons dans un monde rempli d'&eacute;l&eacute;ments observables. Notre inspiration est d&eacute;clench&eacute;e par notre ambition de r&eacute;aliser davantage. Nos r&ecirc;ves r&eacute;v&egrave;lent des blocages sur notre chemin que nous devons r&eacute;soudre pour poursuivre notre voyage et fulfillent nos r&ecirc;ves. Depuis le moment où un jeune &eacute;tudiant utilise une calculatrice pour r&eacute;soudre une &eacute;quation complexe jusqu'au moment où ce m&ecirc;me &eacute;tudiant devient un astronaute, calculant la trajectoire des satellites en orbite autour de notre plan&egrave;te.

L'observation est notre capacit&eacute; &agrave; d&eacute;tecter un probl&egrave;me qui emp&ecirc;che la r&eacute;alisation d'un objectif. Les probl&egrave;mes peuvent &ecirc;tre aussi simples que de trouver le bon nombre d'articles sur une &eacute;tag&egrave;re d'&eacute;picerie. Il peut aussi s'agir de comprendre pourquoi nous ne pouvons pas capturer des images de plan&egrave;tes situ&eacute;es &agrave; des millions d'ann&eacute;es-lumi&egrave;re de nous. Ce sont tous des probl&egrave;mes que les ing&eacute;nieurs qualifieraient d'observables.

Plus l'objectif est grand, plus le probl&egrave;me sera complexe. Mais ces petits objectifs nous permettent d'entraîner nos esprits &agrave; s'attaquer &agrave; des probl&egrave;mes plus importants. Étape par &eacute;tape, un probl&egrave;me &agrave; la fois.

### 0.1.1.1 Articulation

D&eacute;crire l'observable est un art en soi. Car d&eacute;crire correctement un probl&egrave;me est la moiti&eacute; du chemin vers sa solution. Plus l'articulation du probl&egrave;me est claire, plus le probl&egrave;me a de chances d'&ecirc;tre compris par d'autres personnes qui nous aident &agrave; r&eacute;soudre ces m&ecirc;mes probl&egrave;mes.

L'articulation n'est pas toujours avec les mots. Elle l'est aussi avec des figures et des formes. Ce n'est pas un hasard si certaines des cultures anciennes les plus avanc&eacute;es ont utilis&eacute; des figures et des formes pour d&eacute;crire leur &eacute;poque et leur histoire. Les figures sont un langage universel, compris et interpr&eacute;t&eacute; par toute personne pouvant s'y r&eacute;f&eacute;rer beaucoup plus rapidement que l'apprentissage d'une langue parl&eacute;e. En fait, une figure ou une forme pourrait &ecirc;tre le moyen le plus optimal d'illustrer une id&eacute;e, car ses images valent des milliers de mots.

L'articulation requiert la passion de r&eacute;soudre le probl&egrave;me. Qu'elle soit &eacute;crite, dite ou illustr&eacute;e. Un esprit passionn&eacute; doit transmettre le message cach&eacute; de la criticit&eacute; du probl&egrave;me &agrave; r&eacute;soudre. L'articulation d'un probl&egrave;me est une grande partie de la fa&ccedil;on dont on peut vendre sa solution. Notre capacit&eacute; &agrave; transmettre une id&eacute;e &agrave; d'autres ing&eacute;nieurs, puis &agrave; ceux qui investiront et utiliseront cette solution, est l'un des aspects les plus importants des logiciels d'ing&eacute;nierie.

### 0.1.1.2 Solutionner

Une partie de l'objectif est la fa&ccedil;on de le fulfilmer. Dans l'industrie de l'ing&eacute;nierie, remplir les objectifs ne peut pas se faire par n'importe quel moyen. Un aspect &eacute;norme de la raison pour laquelle tant de logiciels massifs &eacute;chouent dans le monde est que l'aspect de la solution a &eacute;t&eacute; n&eacute;glig&eacute; comme une partie triviale de l'objectif. Vous avez peut-&ecirc;tre entendu parler de ceux qui, press&eacute;s par le temps, ont d&eacute;cid&eacute; de faire des &eacute;conomies pour atteindre leur objectif. Dans notre norme, il s'agit d'une violation. Une solution ne doit pas seulement r&eacute;pondre &agrave; un objectif, mais elle doit &ecirc;tre un objectif en soi. Ceci en termes d'optimisation, de lisibilit&eacute;, de configurabilit&eacute; et de long&eacute;vit&eacute;.

L'&eacute;laboration de solutions dans le cadre de l'objectif est l'artisanat du logiciel.

## 0.1.2 Mod&eacute;lisation

La mod&eacute;lisation est le deuxi&egrave;me aspect le plus important du g&eacute;nie logiciel. C'est notre capacit&eacute; &agrave; extraire des mod&egrave;les des acteurs d'un probl&egrave;me quelconque. Que ces acteurs soient des &ecirc;tres vivants, des objets ou autres. Par exemple, dans un probl&egrave;me où nous essayons de compter les articles sur une &eacute;tag&egrave;re d'&eacute;picerie, un mod&egrave;le serait pour ces articles. En extrayant uniquement les attributs pertinents pour le probl&egrave;me que nous essayons de r&eacute;soudre, et en rejetant tout le reste.

Un exemple plus simple serait de d&eacute;tecter les articles p&eacute;rissables dans une &eacute;picerie. Le seul attribut qui nous int&eacute;resse ici est la date d'expiration de l'article. Tout le reste, y compris l'&eacute;tiquette, la couleur, le poids ou tout autre d&eacute;tail, n'entre pas dans le cadre du processus de mod&eacute;lisation et de la solution.
 
La mod&eacute;lisation ne peut donc pas exister sans un objectif. Comme le but d&eacute;fines la port&eacute;e ou le cadre dans lequel la mod&eacute;lisation doit se produire. La mod&eacute;lisation sans but laisse la porte ouverte &agrave; l'attraction d'un nombre infini d'attributs que chaque &eacute;l&eacute;ment de l'univers observable peut avoir.

La relation entre les attributs de l'objet et de la mod&eacute;lisation est proportionnelle. Plus l'objectif est complexe, plus le processus de mod&eacute;lisation n&eacute;cessitera d'attributs du monde r&eacute;el &agrave; reproduire dans un prototype.

Nous exprimons nos mod&egrave;les dans les langages de programmation comme une classe (`class`). Le probl&egrave;me des articles p&eacute;rissables mentionn&eacute; ci-dessus peut &ecirc;tre repr&eacute;sent&eacute; comme suit :

```csharp
public class Item
{
	public DateTimeOffset ExpirationDate {get; set;}
}
```

Le nom de la classe (`class`) repr&eacute;sente le `type` g&eacute;n&eacute;ral de l'&eacute;l&eacute;ment. Étant donn&eacute; que tous les &eacute;l&eacute;ments ont exactement le m&ecirc;me attribut `ExpirationDate`, le nom doit rester aussi g&eacute;n&eacute;rique que possible.

Maintenant, imaginez si notre objectif devenait un peu plus complexe. Supposons que le nouveau probl&egrave;me est de pouvoir identifier les articles p&eacute;rissables les plus chers afin que le magasin puisse les vendre avant les articles les moins chers. Dans ce cas, notre mod&egrave;le n&eacute;cessiterait un nouvel attribut tel que `price` (prix) afin qu'un programme informatique ou une solution puisse d&eacute;terminer lequel a le plus de valeur. Voici &agrave; quoi ressemblerait notre nouveau mod&egrave;le :

```csharp
public class Item
{
	public double Price {get; set;}
	public DateTimeOffset ExpirationDate {get; set;}
}
```

### 0.1.2.0 Types de mod&egrave;les
Les mod&egrave;les r&eacute;gissent l'ensemble du processus de simulation d'un probl&egrave;me (et de sa solution). Les mod&egrave;les eux-m&ecirc;mes se divisent en trois cat&eacute;gories principales, les supports de donn&eacute;es, les op&eacute;rations et les configurations. Discutons de ces types dans les sections suivantes :

#### 0.1.2.0.0 Mod&egrave;les de supports de donn&eacute;es
Les mod&egrave;les de support de donn&eacute;es ont un objectif principal qui est de transporter des points de donn&eacute;es &agrave; travers les syst&egrave;mes. Les mod&egrave;les de supports de donn&eacute;es peuvent varier en fonction du type de donn&eacute;es qu'ils transportent. Certains mod&egrave;les de support de donn&eacute;es porteront d'autres mod&egrave;les pour repr&eacute;senter un syst&egrave;me complexe. Certains autres repr&eacute;senteront simplement des r&eacute;f&eacute;rences aux points de donn&eacute;es d'origine qu'ils repr&eacute;sentent.

Les mod&egrave;les de supports de donn&eacute;es de mani&egrave;re relationnelle peuvent &ecirc;tre divis&eacute;s en trois cat&eacute;gories diff&eacute;rentes. Ces cat&eacute;gories permettent de mieux comprendre quels sont les domaines prioritaires en termes de d&eacute;veloppement, de conception et d'ing&eacute;nierie. Par exemple, nous ne pouvons pas commencer &agrave; d&eacute;velopper des mod&egrave;les secondaires/de support si nous n'avons pas d'abord mis en place nos mod&egrave;les principaux. Parlons de ces cat&eacute;gories en d&eacute;tails :

#### 0.1.2.0.0.0 Mod&egrave;les primaires
Les mod&egrave;les primaires sont les piliers de tout syst&egrave;me. Un syst&egrave;me donn&eacute; ne peut avancer en termes de conception et d'ing&eacute;nierie sans une d&eacute;finition claire et une mat&eacute;rialisation de ces mod&egrave;les primaires. Par exemple, si nous construisons un syst&egrave;me scolaire, des mod&egrave;les tels que `Student` (&eacute;tudiant), `Teacher` (enseignant) et `Course` (cours) sont consid&eacute;r&eacute;s comme des mod&egrave;les primaires.

Nous appelons ces mod&egrave;les Primaires car ils se suffisent &agrave; eux-m&ecirc;mes. Ils ne s'appuient pas physiquement sur un autre mod&egrave;le pour exister. Ce qui signifie qu'un mod&egrave;le primaire donn&eacute; tel que `Student` peut toujours exister dans un syst&egrave;me scolaire, qu'un enregistrement `Teacher` existe ou non. C'est ce qu'on appelle la d&eacute;pendance physique. Les mod&egrave;les principaux d'un sch&eacute;ma de stockage relationnel ne contiennent aucune cl&eacute; &eacute;trang&egrave;re ou r&eacute;f&eacute;rence &agrave; un autre mod&egrave;le physique.

Les mod&egrave;les primaires peuvent cependant s'appuyer conceptuellement ou logiquement sur d'autres mod&egrave;les. Par exemple, un mod&egrave;le `Student` a une relation logique avec un `Teacher`. Tout simplement parce qu'il ne peut jamais y avoir d'&eacute;tudiant sans enseignat et vice versa. Un mod&egrave;le `Student` a &eacute;galement une relation conceptuelle avec son h&ocirc;te et les services d'h&eacute;bergement voisins. Par exemple, il existe une relation conceptuelle entre un mod&egrave;le `Student` et un mod&egrave;le "Notification" en termes de flux m&eacute;tier. Conceptuellement, n'importe quel &eacute;tudiant dans n'importe quelle &eacute;cole s'appuie sur les notifications pour assister &agrave; certains cours, effectuer certains devoirs ou tout autre &eacute;v&eacute;nement.

#### 0.1.2.0.0.1 Mod&egrave;les secondaires
Les mod&egrave;les secondaires, quant &agrave; eux, d&eacute;pendent fortement des mod&egrave;les primaires. Dans un mod&egrave;le de base de donn&eacute;es relationnelle, les mod&egrave;les secondaires ont g&eacute;n&eacute;ralement des cl&eacute;s &eacute;trang&egrave;res qui font r&eacute;f&eacute;rence &agrave; un autre mod&egrave;le dans le sch&eacute;ma global de la base de donn&eacute;es. Mais m&ecirc;me dans les syst&egrave;mes de stockage non relationnels, les mod&egrave;les secondaires peuvent &ecirc;tre repr&eacute;sent&eacute;s comme des entit&eacute;s imbriqu&eacute;es dans une entit&eacute; plus grande donn&eacute;e ou avoir une r&eacute;f&eacute;rence libre &agrave; une autre entit&eacute;.

Parlons de quelques exemples de mod&egrave;les secondaires. un mod&egrave;le `Commentaire` (commentaire) dans une plate-forme de m&eacute;dias sociaux ne peut exister sans un mod&egrave;le `Post` (Publication). Vous ne pouvez tout simplement pas commenter quelque chose qui n'existe pas. Dans une base de donn&eacute;es relationnelle, le mod&egrave;le de commentaires ressemblerait &agrave; ceci :

<br />

<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155897099-5dd8aa3d-f6c2-4504-ba42-5e911c21a09a.png" />
</div>

<br />

Dans l'exemple ci-dessus, un mod&egrave;le secondaire `Comment` a une cl&eacute; &eacute;trang&egrave;re `PostId` r&eacute;f&eacute;ren&ccedil;ant la cl&eacute; primaire `Id` dans un mod&egrave;le `Post`. Dans un syst&egrave;me non relationnel, les mod&egrave;les secondaires peuvent facilement &ecirc;tre identifi&eacute;s comme des objets imbriqu&eacute;s dans une entit&eacute; donn&eacute;e. Voici un exemple :

```json
{
	"id": "some-id",
	"content": "some post",
	"comments": [
		{
			"id": "comment-id",
			"content": "some comment"
		}
	]
}
```

Les mod&egrave;les secondaires en g&eacute;n&eacute;ral peuvent avoir des relations logiques et conceptuelles avec d'autres mod&egrave;les au sein de leurs syst&egrave;mes h&ocirc;tes, voisins ou externes. Cependant, leurs chances d'avoir ces relations conceptuelles sont bien moindres que les mod&egrave;les primaires.

#### 0.1.2.0.0.2 Mod&egrave;les relationnels
Les mod&egrave;les relationnels sont des connecteurs entre deux mod&egrave;les primaires. Leur principale responsabilit&eacute; est de mat&eacute;rialiser une relation plusieurs-&agrave;-plusieurs entre deux entit&eacute;s. Par exemple, un &eacute;tudiant (`Student`) peut avoir plusieurs enseignants et un enseignant `Teacher` peut avoir plusieurs &eacute;tudiants. Dans ce cas un mod&egrave;le interm&eacute;diaire.

Les mod&egrave;les relationnels ne sont pas cens&eacute;s contenir de d&eacute;tails. Ils ne contiennent que des r&eacute;f&eacute;rences &agrave; d'autres mod&egrave;les et c'est leur cl&eacute; primaire. Une cl&eacute; composite qui agr&egrave;ge deux ou plusieurs cl&eacute;s &eacute;trang&egrave;res en son sein. Prenons un exemple :

<br />

<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155897988-f865d0ef-9e22-421f-afe8-8d987bb67464.png" />
</div>

<br />

#### 0.1.2.0.0.3 Mod&egrave;les hybrides
Il existe une situation où un mod&egrave;le connecte plusieurs entit&eacute;s mais transporte &eacute;galement ses propres donn&eacute;es. Je d&eacute;conseille fortement de suivre cette voie pour maintenir un niveau de puret&eacute; dans la conception de votre syst&egrave;me et contr&ocirc;ler la complexit&eacute; de vos mod&egrave;les. Cependant, cette approche est parfois une option n&eacute;cessaire pour proc&eacute;der &agrave; une certaine impl&eacute;mentation ou &agrave; un flux commercial. Dans ce cas, nous pouvons proposer un mod&egrave;le hybride qui peut porter certains d&eacute;tails sur la relation entre deux entit&eacute;s ind&eacute;pendantes.

Voici un exemple de mod&egrave;le hybride qui peut se produire dans la r&eacute;alit&eacute;. Dans un sc&eacute;nario de suppression r&eacute;versible, un mod&egrave;le hybride peut d&eacute;crire le d&eacute;tachement entre deux entit&eacute;s dans une relation plusieurs &agrave; plusieurs. Supposons qu'un membre du groupe ne souhaite plus faire partie d'un certain groupe. Nous consid&eacute;rons leur appartenance au groupe comme d&eacute;sactiv&eacute;e (`Deactivated`) avec une raison jointe sans r&eacute;ellement supprimer compl&egrave;tement l'enregistrement. Voici &agrave; quoi cela ressemblerait :

<br />
<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155970437-3599c84c-b27a-471f-979a-17b624dd6b63.png" />
</div>
<br />

Dans un mod&egrave;le de donn&eacute;es non relationnel, l'int&eacute;grit&eacute; du r&eacute;f&eacute;rencement peut devenir un peu plus l&acirc;che compte tenu de la nature lin&eacute;aire de ce sch&eacute;ma. Les mod&egrave;les hybrides combinent les deux mod&egrave;les secondaires dans la mani&egrave;re dont ils r&eacute;f&eacute;rencent les mod&egrave;les primaires, et ils mettent en oeuvre une nature relationnelle dans laquelle ils permettent &agrave; plusieurs entit&eacute;s de se relier les unes aux autres sans exclusivit&eacute;.

#### 0.1.2.0.1 Mod&egrave;les op&eacute;rationnels
Les mod&egrave;les op&eacute;rationnels ciblent principalement l'aspect simulation de tout syst&egrave;me logiciel. Pensez &agrave; toutes les op&eacute;rations primitives, complexes et d'exposition qu'un sc&eacute;nario simple pourrait n&eacute;cessiter pour qu'une simulation r&eacute;ussie soit mise en oeuvre. Supposons que nous essayons de r&eacute;soudre un probl&egrave;me où nous pouvons simplifier les inscriptions des &eacute;tudiants dans une &eacute;cole. Le processus d'inscription n&eacute;cessitera une simulation pour ajouter ces informations sur les &eacute;tudiants dans un syst&egrave;me informatis&eacute;.

Les mod&egrave;les op&eacute;rationnels g&eacute;reront l'exposition, le traitement et l'int&eacute;gration de l'ensemble de ce processus, en offrant des services qui offrent des API/UI pour saisir, publier, ajouter et ins&eacute;rer/perserver les informations des &eacute;tudiants dans certains syst&egrave;mes scolaires.

Les mod&egrave;les op&eacute;rationnels peuvent &ecirc;tre divis&eacute;s en trois cat&eacute;gories principales, qui sont : l'int&eacute;gration, le traitement et l'exposition. Le standard se concentre fortement sur les mod&egrave;les op&eacute;rationnels car ils repr&eacute;sentent le coeur de tout syst&egrave;me en termes de flux commerciaux. Les mod&egrave;les op&eacute;rationnels sont &eacute;galement l&agrave; où la plupart des ressources de d&eacute;veloppement et de conception vont dans tout effort de d&eacute;veloppement logiciel.

Parlons des mod&egrave;les op&eacute;rationnels ici.

#### 0.1.2.0.1.0 Mod&egrave;les d'int&eacute;gration (Courtiers ou Brokers)
La principale responsabilit&eacute; des mod&egrave;les op&eacute;rationnels d'int&eacute;gration est de connecter tout syst&egrave;me existant &agrave; des ressources externes. Ces ressources peuvent &ecirc;tre localis&eacute;es dans l'environnement de ce syst&egrave;me comme la lecture de la date ou de l'heure actuelle ou &agrave; distance comme l'appel d'une API externe ou la persistance de donn&eacute;es dans une base de donn&eacute;es.

Nous appelons ces mod&egrave;les d'int&eacute;gration des Brokers. Ils jouent le r&ocirc;le de liaison entre les mod&egrave;les op&eacute;rationnels de traitement et les syst&egrave;mes externes. Voici un exemple :

```csharp
public partial class ApiBroker
{
	public async ValueTask<Student> PostStudentAsync(Student student) =>
		this.apiBroker.PostAsync<Student>(student, url);
}
```

Le mod&egrave;le d'int&eacute;gration ci-dessus offre la possibilit&eacute; d'appeler une API externe, tout en extrayant les d&eacute;tails de configuration des mod&egrave;les op&eacute;rationnels de traitement.

Comme tout autre type de mod&egrave;le op&eacute;rationnel, ils ne contiennent pas de donn&eacute;es, mais utilisent plut&ocirc;t des membres de classe priv&eacute;s et des constantes pour partager des donn&eacute;es internes entre ses m&eacute;thodes publiques et priv&eacute;es. Le `ApiBroker` ici en tant que mod&egrave;le repr&eacute;sente une simulation d'int&eacute;gration avec un syst&egrave;me externe.

Nous discuterons en d&eacute;tail des courtiers dans les prochains chapitres pour faire la lumi&egrave;re sur les r&egrave;gles et les directives relatives au d&eacute;veloppement de courtiers avec des ressources ou des syst&egrave;mes externes.

#### 0.1.2.0.1.1 Mod&egrave;les de traitement/du processing (Services)
Les mod&egrave;les de traitement (Ou du processing) sont les d&eacute;tenteurs de toutes les simulations m&eacute;tier. Des choses comme les inscriptions d'&eacute;tudiants, la demande d'une nouvelle carte de biblioth&egrave;que ou simplement la r&eacute;cup&eacute;ration de certaines informations sur les &eacute;tudiants en fonction de certains crit&egrave;res. Les mod&egrave;les de traitement eux-m&ecirc;mes peuvent &ecirc;tre primitifs/fondamentaux, d'ordre sup&eacute;rieur/de traitement ou avanc&eacute;s/orchestrateurs.

Les mod&egrave;les du processing en g&eacute;n&eacute;ral s'appuient sur des mod&egrave;les d'int&eacute;gration, ou sont autonomes comme les services de traitement informatique ou s'appuient les uns sur les autres.

Voici un exemple de service fondamental/primitif simple :

```csharp
public partial class StudentService : IStudentService
{
	private readonly IStorageBroker storageBroker;
	...

	public async ValueTask<Student> AddStudentAsync(Student student) =>
		await this.storageBroker.InsertStudentAsync(student);
}
```

Un service d'ordre sup&eacute;rieur ferait/ressemblerait &agrave; ceci :

```csharp
public partial class StudentProcessingService : IStudentProcessingService
{
	private readonly IStudentService studentService;
	...

	public async ValueTask<Student> UpsertStudentAsync(Student student)
	{
		....

		Student maybeStudent = await this.studentService
			.RetrieveStudentByIdAsync(student.Id);
		
		return maybeStudent switch
		{
			null => await this.studentService.AddStudentAsync(student),
			_ => await this.studentService.ModifyStudentAsync(student)
		}
	}
}
```

Des services de type orchestration plus avanc&eacute;s combineraient plusieurs services de traitement ou de base comme suit :
```csharp
public partial class StudentOrchestrationService : IStudentOrchestrationService
{
	private readonly IStudentProcessingService studentProcessingService;
	private readonly IStudentLibraryCardProcessingService studentLibraryCardProcessingService;
	...

	public async ValueTask<Student> RegisterStudentAsync(Student student)
	{
		....
		Student upsertedStudent = await this.studentProcessingService
			.UpsertStudentAsync(student);

		...

		await this.studentLibraryProcessingService.AddStudentLibraryCardAsync(studentLibraryCard);
	}
}
```

En g&eacute;n&eacute;ral, les mod&egrave;les op&eacute;rationnels ne concernent que la nature de la simulation ou du traitement de certains mod&egrave;les de support de donn&eacute;es, ils ne concernent pas la r&eacute;tention de donn&eacute;es, ni la conservation d'un statut. En g&eacute;n&eacute;ral, les mod&egrave;les op&eacute;rationnels sont sans &eacute;tat dans le sens où ils ne conservent aucun des d&eacute;tails qui les ont parcourus, &agrave; part la d&eacute;l&eacute;gation de la journalisation &agrave; des fins d'observabilit&eacute; et de surveillance.

#### 0.1.2.0.1.2 Mod&egrave;les d'exposition (Exposers)
Les mod&egrave;les d'exposition g&egrave;rent l'IHM dans tous les sc&eacute;narios où un humain et un syst&egrave;me doivent interagir. Il peut s'agir de simples API RESTful, de SDK ou simplement d'une interface utilisateur comme dans les applications Web, mobiles ou de bureau, y compris les syst&egrave;mes/terminaux bas&eacute;s sur la ligne de commande.

Les mod&egrave;les op&eacute;rationnels d'exposition sont comme les mod&egrave;les d'int&eacute;gration, ils permettent au monde ext&eacute;rieur d'interagir avec votre syst&egrave;me. Ils se trouvent &agrave; l'autre bout de tout syst&egrave;me et sont responsables de l'acheminement de chaque demande, communication ou appel vers les mod&egrave;les op&eacute;rationnels appropri&eacute;s. Les mod&egrave;les d'exposition ne communiquent jamais directement avec les mod&egrave;les d'int&eacute;gration, et ils n'ont aucune configuration en leur sein autre que leurs d&eacute;pendances inject&eacute;es via leurs constructeurs.

Les mod&egrave;les d'exposition peuvent avoir leur propre langage en termes d'op&eacute;rations, par exemple, un mod&egrave;le d'int&eacute;gration peut utiliser un langage tel que "InsertStudent", tandis qu'un mod&egrave;le d'exposition pour un point de terminaison API utiliserait un langage tel que "PostStudent" pour exprimer la m&ecirc;me op&eacute;ration dans un contexte d'exposition.

Voici un exemple de mod&egrave;les d'exposition :

```csharp
public class StudentsController
{
	private readonly IStudentOrchestrationService studentOrchestrationService;

	[HttpGet]
	public async ValueTask<ActionResult<Student>> PostStudentAsync(Student student)
	{
		Student registeredStudent = await this.studentOrchestrationService
			.RegisterStudentAsync(student);

		return Ok(registeredStudent);
	}
}
```

Le mod&egrave;le ci-dessus expose un point de terminaison API pour la communication RESTful afin d'offrir la possibilit&eacute; d'inscrire les &eacute;tudiants dans un syst&egrave;me scolaire. Nous discuterons plus en d&eacute;tail des types de mod&egrave;les d'exposition en fonction du contexte et du syst&egrave;me dans lequel ils sont mis en oeuvre.

#### 0.1.2.0.2 Mod&egrave;les de configuration
Le dernier type de mod&egrave;les dans tout syst&egrave;me sont les mod&egrave;les de configuration. Ils peuvent repr&eacute;senter le point d'entr&eacute;e dans n'importe quel syst&egrave;me, ou enregistrer des d&eacute;pendances pour n'importe quel syst&egrave;me ou simplement jouer le r&ocirc;le de middleware pour acheminer les URL vers leur fonction respective au sein d'un mod&egrave;le d'exposition.

Les mod&egrave;les de configuration se situent g&eacute;n&eacute;ralement au d&eacute;but du lancement d'un syst&egrave;me, ou g&egrave;rent les communications entrantes et en cours ou g&egrave;rent simplement les op&eacute;rations syst&egrave;me sous-jacentes telles que la mise en cache de la m&eacute;moire, la gestion des threads, etc.

Dans une simple application d'API, vous pouvez voir des mod&egrave;les qui ressemblent &agrave; ceci :

```csharp
public class Startup
{
	public void ConfigureServices(IServices services)
	{
		services.AddTransient<IStorageBroker, StorageBroker>();
		services.AddOAuth();
	}	
}
```

Comme vous pouvez le voir dans l'extrait de code ci-dessus, le mod&egrave;le de configuration  `Startup` offre des capacit&eacute;s pour g&eacute;rer l'enregistrement des contrats bas&eacute; sur l'injection de d&eacute;pendances dans leurs impl&eacute;mentations concr&egrave;tes. Ils peuvent g&eacute;rer l'ajout de s&eacute;curit&eacute; ou la mise en place d'un pipeline middleware. Les mod&egrave;les de configuration sont sp&eacute;cifiques &agrave; la technologie. Ils peuvent diff&eacute;rer d'un framework Play en Scala &agrave; un Spring ou Flex en Python ou Java. Nous d&eacute;crirons les r&egrave;gles de haut niveau selon le standard pour les mod&egrave;les de configuration, mais nous n'approfondirons pas les d&eacute;tails de leur mise en oeuvre.

## 0.1.3 Simulation

L'aspect simulation du g&eacute;nie logiciel est notre capacit&eacute; &agrave; ressembler aux interactions vers et depuis les mod&egrave;les. Par exemple, dans l'exemple de l'&eacute;picerie, une simulation serait l'acte de *vendre* l'article. La vente de l'article n&eacute;cessite plusieurs modifications de l'article en termes de d&eacute;duction du nombre d'articles disponibles et de r&eacute;organisation des articles restants en fonction de l'article disponible le plus pr&eacute;cieux.

Le processus de simulation peut &ecirc;tre d&eacute;crit comme illustrant les relations entre les mod&egrave;les. elles sont programm&eacute;es en tant que `fonctions`, `m&eacute;thodes` ou `routines` et signifient toutes la m&ecirc;me chose. Si nous avons un service logiciel responsable des ventes d'articles, un processus de simulation ressemblerait &agrave; ceci :

```csharp
public class SaleService
{
	public void Sell(Item item) => Items.Remove(item);
}
```

Dans l'exemple ci-dessus, nous avons un mod&egrave;le appel&eacute; `SaleService` qui offre une fonctionnalit&eacute; pour simuler le processus de vente dans le monde r&eacute;el sur un mod&egrave;le d'article. Et c'est ainsi que vous d&eacute;crivez tout dans la programmation orient&eacute;e objet. Tout est objet (issu d'un mod&egrave;le) et ces objets interagissent entre eux (simulation).

Les objets qui interagissent en g&eacute;n&eacute;ral peuvent &ecirc;tre observ&eacute;s dans trois types diff&eacute;rents. Un mod&egrave;le effectuant une action sur un autre mod&egrave;le. Par exemple, le `SaleService` ex&eacute;cute une action de `Sell` sur un mod&egrave;le `Item`. C'est un mod&egrave;le qui interagit avec un autre mod&egrave;le. Dans le m&ecirc;me exemple, une simulation pourrait &ecirc;tre quelque chose qui arrive au mod&egrave;le &agrave; partir d'un autre mod&egrave;le tel que "l'&eacute;l&eacute;ment" dans l'exemple susmentionn&eacute;. Et le dernier type de simulation est un mod&egrave;le interagissant avec lui-m&ecirc;me. Des mod&egrave;les qui s'auto-disposent une fois leur objectif atteint et dont ils ne sont plus n&eacute;cessaires par exemple. Ils s'autod&eacute;truiront.

Le processus de simulation est le troisi&egrave;me et dernier aspect du g&eacute;nie logiciel. Ce que nous approfondirons lorsque nous parlerons des courtiers, des services et des exposants pour illustrer comment le processus de mod&eacute;lisation et de simulation se d&eacute;roule dans le logiciel industriel.

## 0.1.4 R&eacute;sum&eacute;

Si nous consid&eacute;rions la finalit&eacute; comme le domaine ou le cadre dans lequel les mod&egrave;les interagissent. Ensuite, l'illustration suivante devrait simplifier et rendre l'image un peu plus claire :

<br />
	<div align=center>
		<img width="50%" src="https://user-images.githubusercontent.com/16063715/186160196-fa50daf8-dbfc-47c3-8715-9628f8ff269a.png" />
	</div>
<br />

Il est important de comprendre qu'un logiciel informatique peut servir &agrave; plusieurs fins. Les logiciels informatiques peuvent interagir avec d'autres logiciels qui partagent des objectifs communs. Le but du logiciel devient le mod&egrave;le et les int&eacute;grations deviennent les simulations dans cet aspect. Voici un exemple de 10 000 pieds :
<br />
	<div align=center>
		<img width="75%" src="https://user-images.githubusercontent.com/16063715/186160715-21da21d7-754d-452d-a101-d6c9617ad839.png" />
	</div>
<br />

La complexit&eacute; de tout grand syst&egrave;me peut &ecirc;tre tr&egrave;s facilement d&eacute;compos&eacute;e en probl&egrave;mes plus petits si l'aspect d'objectif unique ou de responsabilit&eacute; unique &eacute;tait appliqu&eacute; pour chaque sous-syst&egrave;me. C'est ce que les architectures logicielles modernes appelleraient la granularit&eacute; et la modularisation. Ce dont nous discuterons bri&egrave;vement tout au long de l'aspect architecture du standard.

[*] [Fixer des objectifs, mod&eacute;liser et simuler (Partie 1) - En anglais](https://www.youtube.com/watch?v=Doul1gZKCuU)
